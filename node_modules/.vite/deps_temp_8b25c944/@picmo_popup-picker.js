import "./chunk-CQXHTUV2.js";

// node_modules/picmo/dist/index.js
var U = (s, e, t) => {
  if (!e.has(s))
    throw TypeError("Cannot " + t);
};
var y = (s, e, t) => (U(s, e, "read from private field"), t ? t.call(s) : e.get(s));
var f = (s, e, t) => {
  if (e.has(s))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(s) : e.set(s, t);
};
var A = (s, e, t, o) => (U(s, e, "write to private field"), o ? o.call(s, t) : e.set(s, t), t);
var g = (s, e, t) => (U(s, e, "access private method"), t);
var Ve = "14.0";
function De(s, e, t) {
  let o = `https://cdn.jsdelivr.net/npm/emojibase-data@${e}/${s}`;
  return typeof t == "function" ? o = t(s, e) : typeof t == "string" && (o = `${t}/${s}`), o;
}
async function ae(s, e = {}) {
  const {
    local: t = false,
    version: o = "latest",
    cdnUrl: i,
    ...r
  } = e, a = De(s, o, i), n = t ? localStorage : sessionStorage, l = `emojibase/${o}/${s}`, m = n.getItem(l);
  if (m)
    return Promise.resolve(JSON.parse(m));
  const d = await fetch(a, {
    credentials: "omit",
    mode: "cors",
    redirect: "error",
    ...r
  });
  if (!d.ok)
    throw new Error("Failed to load Emojibase dataset.");
  const h = await d.json();
  try {
    n.setItem(l, JSON.stringify(h));
  } catch {
  }
  return h;
}
var Be = {
  discord: "joypixels",
  slack: "iamcal"
};
async function me(s, e, t) {
  var o;
  return ae(`${s}/shortcodes/${(o = Be[e]) !== null && o !== void 0 ? o : e}.json`, t);
}
function k(s, e) {
  if (e.length === 0)
    return s;
  const t = new Set(s.shortcodes);
  return e.forEach((o) => {
    const i = o[s.hexcode];
    Array.isArray(i) ? i.forEach((r) => t.add(r)) : i && t.add(i);
  }), s.shortcodes = [...t], s.skins && s.skins.forEach((o) => {
    k(o, e);
  }), s;
}
function Ne(s, e = []) {
  const t = [];
  return s.forEach((o) => {
    if (o.skins) {
      const {
        skins: i,
        ...r
      } = o;
      t.push(k(r, e)), i.forEach((a) => {
        const n = {
          ...a
        };
        r.tags && (n.tags = [...r.tags]), t.push(k(n, e));
      });
    } else
      t.push(k(o, e));
  }), t;
}
function Oe(s, e) {
  return e.length === 0 || s.forEach((t) => {
    k(t, e);
  }), s;
}
async function Ce(s, e = {}) {
  const {
    compact: t = false,
    flat: o = false,
    shortcodes: i = [],
    ...r
  } = e, a = await ae(`${s}/${t ? "compact" : "data"}.json`, r);
  let n = [];
  return i.length > 0 && (n = await Promise.all(i.map((l) => {
    let m;
    if (l.includes("/")) {
      const [d, h] = l.split("/");
      m = me(d, h, r);
    } else
      m = me(s, l, r);
    return m.catch(() => ({}));
  }))), o ? Ne(a, n) : Oe(a, n);
}
async function je(s, e) {
  return ae(`${s}/messages.json`, e);
}
function q(s, e) {
  const o = s.target.closest("[data-emoji]");
  if (o) {
    const i = e.find((r) => r.emoji === o.dataset.emoji);
    if (i)
      return i;
  }
  return null;
}
function _e(s) {
  var t;
  const e = (t = window.matchMedia) == null ? void 0 : t.call(window, "(prefers-reduced-motion: reduce)");
  return s.animate && !(e != null && e.matches);
}
function ue(s, e) {
  return s.toLowerCase().includes(e.toLowerCase());
}
function He(s, e) {
  let t = null;
  return () => {
    t || (t = window.setTimeout(() => {
      s(), t = null;
    }, e));
  };
}
function Ke(s, e) {
  let t = null;
  return (...o) => {
    t && window.clearTimeout(t), t = window.setTimeout(() => {
      s(...o), t = null;
    }, e);
  };
}
function I(s, e, t, o) {
  if (_e(o) && s.animate)
    return s.animate(e, t).finished;
  const i = t.direction === "normal" ? 1 : 0, r = Object.entries(e).reduce((a, [n, l]) => ({
    ...a,
    [n]: l[i]
  }), {});
  return Object.assign(s.style, r), Promise.resolve();
}
function Q(s) {
  var t;
  const e = document.createElement("template");
  return e.innerHTML = s, (t = e.content) == null ? void 0 : t.firstElementChild;
}
async function Ue(s) {
  const e = new TextEncoder().encode(s), t = await crypto.subtle.digest("SHA-256", e);
  return Array.from(new Uint8Array(t)).map((i) => i.toString(16).padStart(2, "0")).join("");
}
function p(...s) {
  return s.reduce((e, t) => ({
    ...e,
    [t]: ne(t)
  }), {});
}
function ne(s) {
  return `picmo__${s}`;
}
function V(s) {
  for (; s.firstChild; )
    s.removeChild(s.firstChild);
  return s;
}
function w(s, ...e) {
  V(s).append(...e);
}
function ke(s) {
  try {
    return window[s].length, true;
  } catch {
    return false;
  }
}
function xe() {
  return ke("sessionStorage");
}
function qe() {
  return ke("localStorage");
}
function x(s) {
  var e;
  return {
    emoji: s.emoji,
    label: s.label,
    tags: s.tags,
    skins: (e = s.skins) == null ? void 0 : e.map((t) => x(t)),
    order: s.order,
    custom: false,
    hexcode: s.hexcode,
    version: s.version
  };
}
function B(s, e, t) {
  var o;
  return t && !t.some((i) => i.order === s.group) ? false : ue(s.label, e) || ((o = s.tags) == null ? void 0 : o.some((i) => ue(i, e)));
}
var Ee = class {
  constructor(e = "en") {
    this.locale = e;
  }
};
var We = [
  (s, e) => (s.hexcode === "1F91D" && e < 14 && (s.skins = []), s),
  (s, e) => (s.skins && (s.skins = s.skins.filter((t) => !t.version || t.version <= e)), s)
];
function Ge(s, e) {
  return We.some((t) => t(s, e) === null) ? null : s;
}
function N(s, e) {
  return s.filter((t) => Ge(t, e) !== null);
}
var W = {};
function Se(s) {
  return W[s] || (W[s] = new Je(s)), W[s];
}
Se.deleteDatabase = (s) => {
};
var Je = class extends Ee {
  open() {
    return Promise.resolve();
  }
  delete() {
    return Promise.resolve();
  }
  close() {
  }
  isPopulated() {
    return Promise.resolve(false);
  }
  getEmojiCount() {
    return Promise.resolve(this.emojis.length);
  }
  getEtags() {
    return Promise.resolve({ foo: "bar" });
  }
  getHash() {
    return Promise.resolve("");
  }
  populate(e) {
    return this.categories = e.groups, this.emojis = e.emojis, Promise.resolve();
  }
  getCategories(e) {
    var o;
    let t = this.categories.filter((i) => i.key !== "component");
    if (e.showRecents && t.unshift({ key: "recents", order: -1 }), (o = e.custom) != null && o.length && t.push({ key: "custom", order: 10 }), e.categories) {
      const i = e.categories;
      t = t.filter((r) => i.includes(r.key)), t.sort((r, a) => i.indexOf(r.key) - i.indexOf(a.key));
    } else
      t.sort((i, r) => i.order - r.order);
    return Promise.resolve(t);
  }
  getEmojis(e, t) {
    const o = this.emojis.filter((i) => i.group === e.order).filter((i) => i.version <= t).sort((i, r) => i.order != null && r.order != null ? i.order - r.order : 0).map(x);
    return Promise.resolve(N(o, t));
  }
  searchEmojis(e, t, o, i) {
    const r = this.emojis.filter((l) => B(l, e, i) && l.version <= o).map(x), a = t.filter((l) => B(l, e, i)), n = [
      ...N(r, o),
      ...a
    ];
    return Promise.resolve(n);
  }
  setMeta(e) {
    this.meta = e;
  }
};
function Ze(s, e) {
  const t = `https://cdn.jsdelivr.net/npm/emojibase-data@${s}/${e}`;
  return {
    emojisUrl: `${t}/data.json`,
    messagesUrl: `${t}/messages.json`
  };
}
async function pe(s) {
  try {
    return (await fetch(s, { method: "HEAD" })).headers.get("etag");
  } catch {
    return null;
  }
}
function Ye(s) {
  const { emojisUrl: e, messagesUrl: t } = Ze("latest", s);
  try {
    return Promise.all([
      pe(e),
      pe(t)
    ]);
  } catch {
    return Promise.all([null, null]);
  }
}
async function Qe(s, e, t) {
  let o;
  try {
    o = await s.getEtags();
  } catch {
    o = {};
  }
  const { storedEmojisEtag: i, storedMessagesEtag: r } = o;
  if (t !== r || e !== i) {
    const [a, n] = await Promise.all([je(s.locale), Ce(s.locale)]);
    await s.populate({
      groups: a.groups,
      emojis: n,
      emojisEtag: e,
      messagesEtag: t
    });
  }
}
async function Xe(s, e) {
  const t = await s.getHash();
  return e !== t;
}
async function Fe(s, e, t) {
  let o = t || e(s);
  try {
    await o.open();
  } catch {
    console.warn("[picmo] IndexedDB not available, falling back to InMemoryStoreFactory"), o = Se(s);
  }
  return o;
}
async function et(s, e, t) {
  if (!xe() && typeof window < "u")
    throw new Error("Session storage is required to use CDN emoji data.");
  const o = await Fe(s, e, t), [i, r] = await Ye(s);
  if (await o.isPopulated())
    i && r && await Qe(o, i, r);
  else {
    const [a, n] = await Promise.all([je(s), Ce(s)]);
    await o.populate({ groups: a.groups, emojis: n, emojisEtag: i, messagesEtag: r });
  }
  return o;
}
async function tt(s, e, t, o, i) {
  const r = await Fe(s, e, i), a = await Ue(o);
  return (!await r.isPopulated() || await Xe(r, a)) && await r.populate({ groups: t.groups, emojis: o, hash: a }), r;
}
async function ce(s, e, t, o, i) {
  return t && o ? tt(s, e, t, o, i) : et(s, e, i);
}
var st = class {
  constructor() {
    this.handleKeyDown = this.handleKeyDown.bind(this);
  }
  activate(e) {
    this.rootElement = e, this.rootElement.addEventListener("keydown", this.handleKeyDown);
  }
  deactivate() {
    var e;
    (e = this.rootElement) == null || e.removeEventListener("keydown", this.handleKeyDown);
  }
  get focusableElements() {
    return this.rootElement.querySelectorAll('input, [tabindex="0"]');
  }
  get lastFocusableElement() {
    return this.focusableElements[this.focusableElements.length - 1];
  }
  get firstFocusableElement() {
    return this.focusableElements[0];
  }
  checkFocus(e, t, o) {
    e.target === t && (o.focus(), e.preventDefault());
  }
  handleKeyDown(e) {
    e.key === "Tab" && this.checkFocus(
      e,
      e.shiftKey ? this.firstFocusableElement : this.lastFocusableElement,
      e.shiftKey ? this.lastFocusableElement : this.firstFocusableElement
    );
  }
};
var {
  light: ot,
  dark: Ns,
  auto: Os
} = p("light", "dark", "auto");
var c = class {
  constructor({ template: e, classes: t, parent: o }) {
    this.isDestroyed = false, this.appEvents = {}, this.uiEvents = [], this.uiElements = {}, this.ui = {}, this.template = e, this.classes = t, this.parent = o, this.keyBindingHandler = this.keyBindingHandler.bind(this);
  }
  initialize() {
    this.bindAppEvents();
  }
  setCustomEmojis(e) {
    this.customEmojis = e;
  }
  setEvents(e) {
    this.events = e;
  }
  setPickerId(e) {
    this.pickerId = e;
  }
  emit(e, ...t) {
    this.events.emit(e, ...t);
  }
  setI18n(e) {
    this.i18n = e;
  }
  setRenderer(e) {
    this.renderer = e;
  }
  setEmojiData(e) {
    this.emojiDataPromise = e, e.then((t) => {
      this.emojiData = t;
    });
  }
  updateEmojiData(e) {
    this.emojiData = e, this.emojiDataPromise = Promise.resolve(e);
  }
  setOptions(e) {
    this.options = e;
  }
  renderSync(e = {}) {
    return this.el = this.template.renderSync({
      classes: this.classes,
      i18n: this.i18n,
      pickerId: this.pickerId,
      ...e
    }), this.postRender(), this.el;
  }
  async render(e = {}) {
    return await this.emojiDataPromise, this.el = await this.template.renderAsync({
      classes: this.classes,
      i18n: this.i18n,
      pickerId: this.pickerId,
      ...e
    }), this.postRender(), this.el;
  }
  postRender() {
    this.bindUIElements(), this.bindKeyBindings(), this.bindUIEvents(), this.scheduleShowAnimation();
  }
  bindAppEvents() {
    Object.keys(this.appEvents).forEach((e) => {
      this.events.on(e, this.appEvents[e], this);
    }), this.events.on("data:ready", this.updateEmojiData, this);
  }
  unbindAppEvents() {
    Object.keys(this.appEvents).forEach((e) => {
      this.events.off(e, this.appEvents[e]);
    }), this.events.off("data:ready", this.updateEmojiData);
  }
  keyBindingHandler(e) {
    const t = this.keyBindings[e.key];
    t && t.call(this, e);
  }
  bindKeyBindings() {
    this.keyBindings && this.el.addEventListener("keydown", this.keyBindingHandler);
  }
  unbindKeyBindings() {
    this.keyBindings && this.el.removeEventListener("keydown", this.keyBindingHandler);
  }
  bindUIElements() {
    this.ui = Object.keys(this.uiElements).reduce((e, t) => ({
      ...e,
      [t]: this.el.querySelector(this.uiElements[t])
    }), {});
  }
  bindUIEvents() {
    this.uiEvents.forEach((e) => {
      e.handler = e.handler.bind(this), (e.target ? this.ui[e.target] : this.el).addEventListener(e.event, e.handler, e.options);
    });
  }
  unbindUIEvents() {
    this.uiEvents.forEach((e) => {
      (e.target ? this.ui[e.target] : this.el).removeEventListener(e.event, e.handler);
    });
  }
  destroy() {
    this.unbindAppEvents(), this.unbindUIEvents(), this.unbindKeyBindings(), this.el.remove(), this.isDestroyed = true;
  }
  scheduleShowAnimation() {
    if (this.parent) {
      const e = new MutationObserver((t) => {
        const [o] = t;
        o.type === "childList" && o.addedNodes[0] === this.el && (_e(this.options) && this.animateShow && this.animateShow(), e.disconnect);
      });
      e.observe(this.parent, { childList: true });
    }
  }
  static childEvent(e, t, o, i = {}) {
    return { target: e, event: t, handler: o, options: i };
  }
  static uiEvent(e, t, o = {}) {
    return { event: e, handler: t, options: o };
  }
  static byClass(e) {
    return `.${e}`;
  }
};
var it = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M256 512C114.6 512 0 397.4 0 256C0 114.6 114.6 0 256 0C397.4 0 512 114.6 512 256C512 397.4 397.4 512 256 512zM232 256C232 264 236 271.5 242.7 275.1L338.7 339.1C349.7 347.3 364.6 344.3 371.1 333.3C379.3 322.3 376.3 307.4 365.3 300L280 243.2V120C280 106.7 269.3 96 255.1 96C242.7 96 231.1 106.7 231.1 120L232 256z"/></svg>';
var rt = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M64 496C64 504.8 56.75 512 48 512h-32C7.25 512 0 504.8 0 496V32c0-17.75 14.25-32 32-32s32 14.25 32 32V496zM476.3 0c-6.365 0-13.01 1.35-19.34 4.233c-45.69 20.86-79.56 27.94-107.8 27.94c-59.96 0-94.81-31.86-163.9-31.87C160.9 .3055 131.6 4.867 96 15.75v350.5c32-9.984 59.87-14.1 84.85-14.1c73.63 0 124.9 31.78 198.6 31.78c31.91 0 68.02-5.971 111.1-23.09C504.1 355.9 512 344.4 512 332.1V30.73C512 11.1 495.3 0 476.3 0z"/></svg>';
var at = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M0 256C0 114.6 114.6 0 256 0C397.4 0 512 114.6 512 256C512 397.4 397.4 512 256 512C114.6 512 0 397.4 0 256zM176.4 240C194 240 208.4 225.7 208.4 208C208.4 190.3 194 176 176.4 176C158.7 176 144.4 190.3 144.4 208C144.4 225.7 158.7 240 176.4 240zM336.4 176C318.7 176 304.4 190.3 304.4 208C304.4 225.7 318.7 240 336.4 240C354 240 368.4 225.7 368.4 208C368.4 190.3 354 176 336.4 176zM259.9 369.4C288.8 369.4 316.2 375.2 340.6 385.5C352.9 390.7 366.7 381.3 361.4 369.1C344.8 330.9 305.6 303.1 259.9 303.1C214.3 303.1 175.1 330.8 158.4 369.1C153.1 381.3 166.1 390.6 179.3 385.4C203.7 375.1 231 369.4 259.9 369.4L259.9 369.4z"/></svg>';
var nt = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M448 64H192C85.96 64 0 149.1 0 256s85.96 192 192 192h256c106 0 192-85.96 192-192S554 64 448 64zM247.1 280h-32v32c0 13.2-10.78 24-23.98 24c-13.2 0-24.02-10.8-24.02-24v-32L136 279.1C122.8 279.1 111.1 269.2 111.1 256c0-13.2 10.85-24.01 24.05-24.01L167.1 232v-32c0-13.2 10.82-24 24.02-24c13.2 0 23.98 10.8 23.98 24v32h32c13.2 0 24.02 10.8 24.02 24C271.1 269.2 261.2 280 247.1 280zM431.1 344c-22.12 0-39.1-17.87-39.1-39.1s17.87-40 39.1-40s39.1 17.88 39.1 40S454.1 344 431.1 344zM495.1 248c-22.12 0-39.1-17.87-39.1-39.1s17.87-40 39.1-40c22.12 0 39.1 17.88 39.1 40S518.1 248 495.1 248z"/></svg>';
var ct = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M112.1 454.3c0 6.297 1.816 12.44 5.284 17.69l17.14 25.69c5.25 7.875 17.17 14.28 26.64 14.28h61.67c9.438 0 21.36-6.401 26.61-14.28l17.08-25.68c2.938-4.438 5.348-12.37 5.348-17.7L272 415.1h-160L112.1 454.3zM191.4 .0132C89.44 .3257 16 82.97 16 175.1c0 44.38 16.44 84.84 43.56 115.8c16.53 18.84 42.34 58.23 52.22 91.45c.0313 .25 .0938 .5166 .125 .7823h160.2c.0313-.2656 .0938-.5166 .125-.7823c9.875-33.22 35.69-72.61 52.22-91.45C351.6 260.8 368 220.4 368 175.1C368 78.61 288.9-.2837 191.4 .0132zM192 96.01c-44.13 0-80 35.89-80 79.1C112 184.8 104.8 192 96 192S80 184.8 80 176c0-61.76 50.25-111.1 112-111.1c8.844 0 16 7.159 16 16S200.8 96.01 192 96.01z"/></svg>';
var lt = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M512 32H120c-13.25 0-24 10.75-24 24L96.01 288c0 53 43 96 96 96h192C437 384 480 341 480 288h32c70.63 0 128-57.38 128-128S582.6 32 512 32zM512 224h-32V96h32c35.25 0 64 28.75 64 64S547.3 224 512 224zM560 416h-544C7.164 416 0 423.2 0 432C0 458.5 21.49 480 48 480h480c26.51 0 48-21.49 48-48C576 423.2 568.8 416 560 416z"/></svg>';
var ht = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M482.3 192C516.5 192 576 221 576 256C576 292 516.5 320 482.3 320H365.7L265.2 495.9C259.5 505.8 248.9 512 237.4 512H181.2C170.6 512 162.9 501.8 165.8 491.6L214.9 320H112L68.8 377.6C65.78 381.6 61.04 384 56 384H14.03C6.284 384 0 377.7 0 369.1C0 368.7 .1818 367.4 .5398 366.1L32 256L.5398 145.9C.1818 144.6 0 143.3 0 142C0 134.3 6.284 128 14.03 128H56C61.04 128 65.78 130.4 68.8 134.4L112 192H214.9L165.8 20.4C162.9 10.17 170.6 0 181.2 0H237.4C248.9 0 259.5 6.153 265.2 16.12L365.7 192H482.3z"/></svg>';
var dt = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M9.375 233.4C3.375 239.4 0 247.5 0 256v128c0 8.5 3.375 16.62 9.375 22.62S23.5 416 32 416h32V224H32C23.5 224 15.38 227.4 9.375 233.4zM464 96H352V32c0-17.62-14.38-32-32-32S288 14.38 288 32v64H176C131.8 96 96 131.8 96 176V448c0 35.38 28.62 64 64 64h320c35.38 0 64-28.62 64-64V176C544 131.8 508.3 96 464 96zM256 416H192v-32h64V416zM224 296C201.9 296 184 278.1 184 256S201.9 216 224 216S264 233.9 264 256S246.1 296 224 296zM352 416H288v-32h64V416zM448 416h-64v-32h64V416zM416 296c-22.12 0-40-17.88-40-40S393.9 216 416 216S456 233.9 456 256S438.1 296 416 296zM630.6 233.4C624.6 227.4 616.5 224 608 224h-32v192h32c8.5 0 16.62-3.375 22.62-9.375S640 392.5 640 384V256C640 247.5 636.6 239.4 630.6 233.4z"/></svg>';
var mt = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
  <defs>
    <radialGradient gradientUnits="userSpaceOnUse" cy="10%" id="gradient-0">
      <stop offset="0" stop-color="hsl(50, 100%, 50%)" />
      <stop offset="1" stop-color="hsl(50, 100%, 60%)" />
    </radialGradient>
  </defs>
  <!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->
  <ellipse stroke="#000" fill="rgba(0, 0, 0, 0.6)" cx="172.586" cy="207.006" rx="39.974" ry="39.974"/>
  <ellipse stroke="#000" fill="rgba(0, 0, 0, 0.6)" cx="334.523" cy="207.481" rx="39.974" ry="39.974"/>
  <ellipse stroke="#000" fill="rgba(0, 0, 0, 0.6)" cx="313.325" cy="356.208" rx="91.497" ry="59.893"/>
  <path fill="#55a7ff" d="M 159.427 274.06 L 102.158 363.286 L 124.366 417.011 L 160.476 423.338 L 196.937 414.736 L 218.502 375.214"></path>
  <path fill="url(#gradient-0)" d="M256 0C397.4 0 512 114.6 512 256C512 397.4 397.4 512 256 512C114.6 512 0 397.4 0 256C0 114.6 114.6 0 256 0zM256 352C290.9 352 323.2 367.8 348.3 394.9C354.3 401.4 364.4 401.7 370.9 395.7C377.4 389.7 377.7 379.6 371.7 373.1C341.6 340.5 301 320 256 320C247.2 320 240 327.2 240 336C240 344.8 247.2 352 256 352H256zM208 369C208 349 179.6 308.6 166.4 291.3C163.2 286.9 156.8 286.9 153.6 291.3C140.6 308.6 112 349 112 369C112 395 133.5 416 160 416C186.5 416 208 395 208 369H208zM303.6 208C303.6 225.7 317.1 240 335.6 240C353.3 240 367.6 225.7 367.6 208C367.6 190.3 353.3 176 335.6 176C317.1 176 303.6 190.3 303.6 208zM207.6 208C207.6 190.3 193.3 176 175.6 176C157.1 176 143.6 190.3 143.6 208C143.6 225.7 157.1 240 175.6 240C193.3 240 207.6 225.7 207.6 208z" />
</svg>`;
var ut = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M500.3 443.7l-119.7-119.7c27.22-40.41 40.65-90.9 33.46-144.7C401.8 87.79 326.8 13.32 235.2 1.723C99.01-15.51-15.51 99.01 1.724 235.2c11.6 91.64 86.08 166.7 177.6 178.9c53.8 7.189 104.3-6.236 144.7-33.46l119.7 119.7c15.62 15.62 40.95 15.62 56.57 0C515.9 484.7 515.9 459.3 500.3 443.7zM79.1 208c0-70.58 57.42-128 128-128s128 57.42 128 128c0 70.58-57.42 128-128 128S79.1 278.6 79.1 208z"/></svg>';
var pt = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M0 256C0 114.6 114.6 0 256 0C397.4 0 512 114.6 512 256C512 397.4 397.4 512 256 512C114.6 512 0 397.4 0 256zM256.3 331.8C208.9 331.8 164.1 324.9 124.5 312.8C112.2 309 100.2 319.7 105.2 331.5C130.1 390.6 188.4 432 256.3 432C324.2 432 382.4 390.6 407.4 331.5C412.4 319.7 400.4 309 388.1 312.8C348.4 324.9 303.7 331.8 256.3 331.8H256.3zM176.4 176C158.7 176 144.4 190.3 144.4 208C144.4 225.7 158.7 240 176.4 240C194 240 208.4 225.7 208.4 208C208.4 190.3 194 176 176.4 176zM336.4 240C354 240 368.4 225.7 368.4 208C368.4 190.3 354 176 336.4 176C318.7 176 304.4 190.3 304.4 208C304.4 225.7 318.7 240 336.4 240z"/></svg>';
var gt = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M500.3 7.251C507.7 13.33 512 22.41 512 31.1V175.1C512 202.5 483.3 223.1 447.1 223.1C412.7 223.1 383.1 202.5 383.1 175.1C383.1 149.5 412.7 127.1 447.1 127.1V71.03L351.1 90.23V207.1C351.1 234.5 323.3 255.1 287.1 255.1C252.7 255.1 223.1 234.5 223.1 207.1C223.1 181.5 252.7 159.1 287.1 159.1V63.1C287.1 48.74 298.8 35.61 313.7 32.62L473.7 .6198C483.1-1.261 492.9 1.173 500.3 7.251H500.3zM74.66 303.1L86.5 286.2C92.43 277.3 102.4 271.1 113.1 271.1H174.9C185.6 271.1 195.6 277.3 201.5 286.2L213.3 303.1H239.1C266.5 303.1 287.1 325.5 287.1 351.1V463.1C287.1 490.5 266.5 511.1 239.1 511.1H47.1C21.49 511.1-.0019 490.5-.0019 463.1V351.1C-.0019 325.5 21.49 303.1 47.1 303.1H74.66zM143.1 359.1C117.5 359.1 95.1 381.5 95.1 407.1C95.1 434.5 117.5 455.1 143.1 455.1C170.5 455.1 191.1 434.5 191.1 407.1C191.1 381.5 170.5 359.1 143.1 359.1zM440.3 367.1H496C502.7 367.1 508.6 372.1 510.1 378.4C513.3 384.6 511.6 391.7 506.5 396L378.5 508C372.9 512.1 364.6 513.3 358.6 508.9C352.6 504.6 350.3 496.6 353.3 489.7L391.7 399.1H336C329.3 399.1 323.4 395.9 321 389.6C318.7 383.4 320.4 376.3 325.5 371.1L453.5 259.1C459.1 255 467.4 254.7 473.4 259.1C479.4 263.4 481.6 271.4 478.7 278.3L440.3 367.1zM116.7 219.1L19.85 119.2C-8.112 90.26-6.614 42.31 24.85 15.34C51.82-8.137 93.26-3.642 118.2 21.83L128.2 32.32L137.7 21.83C162.7-3.642 203.6-8.137 231.6 15.34C262.6 42.31 264.1 90.26 236.1 119.2L139.7 219.1C133.2 225.6 122.7 225.6 116.7 219.1H116.7z"/></svg>';
var yt = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M413.8 447.1L256 448l0 31.99C256 497.7 241.8 512 224.1 512c-17.67 0-32.1-14.32-32.1-31.99l0-31.99l-158.9-.0099c-28.5 0-43.69-34.49-24.69-56.4l68.98-79.59H62.22c-25.41 0-39.15-29.8-22.67-49.13l60.41-70.85H89.21c-21.28 0-32.87-22.5-19.28-37.31l134.8-146.5c10.4-11.3 28.22-11.3 38.62-.0033l134.9 146.5c13.62 14.81 2.001 37.31-19.28 37.31h-10.77l60.35 70.86c16.46 19.34 2.716 49.12-22.68 49.12h-15.2l68.98 79.59C458.7 413.7 443.1 447.1 413.8 447.1z"/></svg>';
var ft = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M224 256c70.7 0 128-57.31 128-128S294.7 0 224 0C153.3 0 96 57.31 96 128S153.3 256 224 256zM274.7 304H173.3c-95.73 0-173.3 77.6-173.3 173.3C0 496.5 15.52 512 34.66 512H413.3C432.5 512 448 496.5 448 477.3C448 381.6 370.4 304 274.7 304zM479.1 320h-73.85C451.2 357.7 480 414.1 480 477.3C480 490.1 476.2 501.9 470 512h138C625.7 512 640 497.6 640 479.1C640 391.6 568.4 320 479.1 320zM432 256C493.9 256 544 205.9 544 144S493.9 32 432 32c-25.11 0-48.04 8.555-66.72 22.51C376.8 76.63 384 101.4 384 128c0 35.52-11.93 68.14-31.59 94.71C372.7 243.2 400.8 256 432 256z"/></svg>';
var vt = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
  <defs>
    <radialGradient id="radial" cy="85%">
      <stop offset="20%" stop-color="var(--color-secondary)" />
      <stop offset="100%" stop-color="var(--color-primary)" />
    </radialGradient>
  </defs>
  <!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->
  <path fill="url('#radial')" d="M506.3 417l-213.3-364c-16.33-28-57.54-28-73.98 0l-213.2 364C-10.59 444.9 9.849 480 42.74 480h426.6C502.1 480 522.6 445 506.3 417zM232 168c0-13.25 10.75-24 24-24S280 154.8 280 168v128c0 13.25-10.75 24-23.1 24S232 309.3 232 296V168zM256 416c-17.36 0-31.44-14.08-31.44-31.44c0-17.36 14.07-31.44 31.44-31.44s31.44 14.08 31.44 31.44C287.4 401.9 273.4 416 256 416z" />
</svg>`;
var wt = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>';
function bt(s, e) {
  const t = Q(e);
  return t.dataset.icon = s, t.classList.add(ne("icon")), t;
}
var ge = {
  clock: it,
  flag: rt,
  frown: at,
  gamepad: nt,
  lightbulb: ct,
  mug: lt,
  plane: ht,
  robot: dt,
  sad: mt,
  search: ut,
  smiley: pt,
  symbols: gt,
  tree: yt,
  users: ft,
  warning: vt,
  xmark: wt
};
var O = {
  recents: "clock",
  "smileys-emotion": "smiley",
  "people-body": "users",
  "animals-nature": "tree",
  "food-drink": "mug",
  activities: "gamepad",
  "travel-places": "plane",
  objects: "lightbulb",
  symbols: "symbols",
  flags: "flag",
  custom: "robot"
};
function Pe(s, e) {
  if (!(s in ge))
    return console.warn(`Unknown icon: "${s}"`), document.createElement("div");
  const t = bt(s, ge[s]);
  return e && t.classList.add(ne(`icon-${e}`)), t;
}
var Ct = {
  mode: "sync"
};
var b;
var E;
var S;
var X;
var F;
var ee;
var P;
var te;
var u = class {
  constructor(e, t = {}) {
    f(this, S);
    f(this, F);
    f(this, P);
    f(this, b, void 0);
    f(this, E, void 0);
    A(this, b, e), A(this, E, t.mode || Ct.mode);
  }
  renderSync(e = {}) {
    const t = Q(y(this, b).call(this, e));
    return g(this, P, te).call(this, t, e), g(this, F, ee).call(this, t), g(this, S, X).call(this, t, e), t;
  }
  async renderAsync(e = {}) {
    const t = Q(y(this, b).call(this, e));
    return g(this, P, te).call(this, t, e), g(this, F, ee).call(this, t), await g(this, S, X).call(this, t, e), t;
  }
  render(e) {
    return y(this, E) === "sync" ? this.renderSync(e) : this.renderAsync(e);
  }
};
b = /* @__PURE__ */ new WeakMap(), E = /* @__PURE__ */ new WeakMap(), S = /* @__PURE__ */ new WeakSet(), X = async function(e, t) {
  const o = e.querySelectorAll("[data-view]"), i = [];
  for (const r of o) {
    const a = t[r.dataset.view];
    a ? r.dataset.render !== "sync" ? i.push(a.render().then((n) => (r.replaceWith(n), n))) : r.replaceWith(a.renderSync()) : r.remove();
  }
  return Promise.all(i);
}, F = /* @__PURE__ */ new WeakSet(), ee = function(e) {
  e.querySelectorAll("i[data-icon]").forEach((o) => {
    const { icon: i, size: r } = o.dataset;
    o.replaceWith(Pe(i, r));
  });
}, P = /* @__PURE__ */ new WeakSet(), te = function(e, t) {
  return e.querySelectorAll("[data-placeholder]").forEach((i) => {
    const r = i.dataset.placeholder;
    if (r && t[r]) {
      const a = t[r];
      i.replaceWith(...[a].flat());
    } else
      console.warn(`Missing placeholder element for key "${r}"`);
  }), e;
};
var jt = p(
  "imagePlaceholder",
  "placeholder"
);
var _t = new u(({ classes: s }) => `
  <div class="${s.placeholder} ${s.imagePlaceholder}"></div>
`);
var kt = class extends c {
  constructor({ classNames: e } = {}) {
    super({ template: _t, classes: jt }), this.classNames = e;
  }
  load(e) {
    const t = document.createElement("img");
    this.classNames && (t.className = this.classNames), t.addEventListener("load", () => {
      this.el.replaceWith(t);
    }, { once: true }), Promise.resolve(e).then((o) => t.src = o);
  }
  renderSync() {
    return super.renderSync(), this.classNames && this.classNames.split(" ").forEach((t) => this.el.classList.add(t)), this.el;
  }
};
var xt = p("customEmoji");
var Et = class {
  renderElement(e) {
    return { content: e };
  }
  renderImage(e = "", t) {
    const o = new kt({ classNames: e });
    return o.renderSync(), { content: o, resolver: () => (o.load(t()), o.el) };
  }
  doRender(e, t, o) {
    if (e.custom)
      return this.renderCustom(e, t, o);
    const { content: i, resolver: r } = this.render(e, o), a = i instanceof Element ? i : i.el;
    return r && r(), a;
  }
  doEmit(e) {
    return e.custom ? this.emitCustom(e) : this.emit(e);
  }
  emitCustom({ url: e, label: t, emoji: o, data: i }) {
    return { url: e, label: t, emoji: o, data: i };
  }
  renderCustom(e, t, o = "") {
    const i = [xt.customEmoji, o].join(" ").trim(), { content: r, resolver: a } = this.renderImage(i, () => e.url), n = r instanceof Element ? r : r.el;
    return a && a(), n;
  }
};
var St = new u(({ emoji: s }) => `<span>${s}</span>`);
var Ft = class extends Et {
  render(e) {
    return this.renderElement(St.renderSync({ emoji: e.emoji }));
  }
  emit({ emoji: e, hexcode: t, label: o }) {
    return { emoji: e, hexcode: t, label: o };
  }
};
var ze = {
  "categories.activities": "Activities",
  "categories.animals-nature": "Animals & Nature",
  "categories.custom": "Custom",
  "categories.flags": "Flags",
  "categories.food-drink": "Food & Drink",
  "categories.objects": "Objects",
  "categories.people-body": "People & Body",
  "categories.recents": "Recently Used",
  "categories.smileys-emotion": "Smileys & Emotion",
  "categories.symbols": "Symbols",
  "categories.travel-places": "Travel & Places",
  "error.load": "Failed to load emojis",
  "recents.clear": "Clear recent emojis",
  "recents.none": "You haven't selected any emojis yet.",
  retry: "Try again",
  "search.clear": "Clear search",
  "search.error": "Failed to search emojis",
  "search.notFound": "No results found",
  search: "Search emojis..."
};
var se = "PicMo";
function Le(s) {
  return new Pt(s);
}
Le.deleteDatabase = (s) => new Promise((e, t) => {
  const o = indexedDB.deleteDatabase(`${se}-${s}`);
  o.addEventListener("success", e), o.addEventListener("error", t);
});
var Pt = class extends Ee {
  async open() {
    const e = indexedDB.open(`${se}-${this.locale}`);
    return new Promise((t, o) => {
      e.addEventListener("success", (i) => {
        var r;
        this.db = (r = i.target) == null ? void 0 : r.result, t();
      }), e.addEventListener("error", o), e.addEventListener("upgradeneeded", async (i) => {
        var a;
        this.db = (a = i.target) == null ? void 0 : a.result, this.db.createObjectStore("category", { keyPath: "order" });
        const r = this.db.createObjectStore("emoji", { keyPath: "emoji" });
        r.createIndex("category", "group"), r.createIndex("version", "version"), this.db.createObjectStore("meta");
      });
    });
  }
  async delete() {
    this.close();
    const e = indexedDB.deleteDatabase(`${se}-${this.locale}`);
    await this.waitForRequest(e);
  }
  close() {
    this.db.close();
  }
  async getEmojiCount() {
    const t = this.db.transaction("emoji", "readonly").objectStore("emoji");
    return (await this.waitForRequest(t.count())).target.result;
  }
  async getEtags() {
    const t = this.db.transaction("meta", "readonly").objectStore("meta"), [o, i] = await Promise.all([
      this.waitForRequest(t.get("emojisEtag")),
      this.waitForRequest(t.get("messagesEtag"))
    ]);
    return {
      storedEmojisEtag: o.target.result,
      storedMessagesEtag: i.target.result
    };
  }
  async setMeta(e) {
    const t = this.db.transaction("meta", "readwrite"), o = t.objectStore("meta");
    return new Promise((i) => {
      t.oncomplete = i, Object.keys(e).filter(Boolean).forEach((a) => {
        o.put(e[a], a);
      });
    });
  }
  async getHash() {
    const t = this.db.transaction("meta", "readonly").objectStore("meta");
    return (await this.waitForRequest(t.get("hash"))).target.result;
  }
  async isPopulated() {
    const t = this.db.transaction("category", "readonly").objectStore("category");
    return (await this.waitForRequest(t.count())).target.result > 0;
  }
  async populate({
    groups: e,
    emojis: t,
    emojisEtag: o,
    messagesEtag: i,
    hash: r
  }) {
    await this.removeAllObjects("category", "emoji");
    const a = [
      this.addObjects("category", e),
      this.addObjects("emoji", t),
      this.setMeta({ emojisEtag: o, messagesEtag: i, hash: r })
    ];
    await Promise.all(a);
  }
  async getCategories(e) {
    var a;
    const o = this.db.transaction("category", "readonly").objectStore("category");
    let r = (await this.waitForRequest(o.getAll())).target.result.filter((n) => n.key !== "component");
    if (e.showRecents && r.unshift({ key: "recents", order: -1 }), (a = e.custom) != null && a.length && r.push({ key: "custom", order: 10 }), e.categories) {
      const n = e.categories;
      r = r.filter((l) => n.includes(l.key)), r.sort((l, m) => n.indexOf(l.key) - n.indexOf(m.key));
    } else
      r.sort((n, l) => n.order - l.order);
    return r;
  }
  async getEmojis(e, t) {
    const r = this.db.transaction("emoji", "readonly").objectStore("emoji").index("category"), l = (await this.waitForRequest(r.getAll(e.order))).target.result.filter((m) => m.version <= t).sort((m, d) => m.order != null && d.order != null ? m.order - d.order : 0).map(x);
    return N(l, t);
  }
  async searchEmojis(e, t, o, i) {
    const r = [];
    return new Promise((a, n) => {
      const d = this.db.transaction("emoji", "readonly").objectStore("emoji").openCursor();
      d.addEventListener("success", (h) => {
        var de;
        const H = (de = h.target) == null ? void 0 : de.result;
        if (!H)
          return a([
            ...N(r, o),
            ...t.filter((Me) => B(Me, e))
          ]);
        const K2 = H.value;
        B(K2, e, i) && K2.version <= o && r.push(x(K2)), H.continue();
      }), d.addEventListener("error", (h) => {
        n(h);
      });
    });
  }
  async waitForRequest(e) {
    return new Promise((t, o) => {
      e.onsuccess = t, e.onerror = o;
    });
  }
  withTransaction(e, t = "readwrite", o) {
    return new Promise((i, r) => {
      const a = this.db.transaction(e, t);
      a.oncomplete = i, a.onerror = r, o(a);
    });
  }
  async removeAllObjects(...e) {
    const t = this.db.transaction(e, "readwrite"), o = e.map((i) => t.objectStore(i));
    await Promise.all(o.map((i) => this.waitForRequest(i.clear())));
  }
  async addObjects(e, t) {
    return this.withTransaction(e, "readwrite", (o) => {
      const i = o.objectStore(e);
      t.forEach((r) => {
        i.add(r);
      });
    });
  }
};
function $e() {
  let s = {};
  return {
    getItem: (e) => s[e],
    setItem: (e, t) => s[e] = t,
    length: Object.keys(s).length,
    clear: () => s = {},
    key: (e) => Object.keys(s)[e],
    removeItem: (e) => delete s[e]
  };
}
var Ae = class {
};
var G = "PicMo:recents";
var Ie = class extends Ae {
  constructor(e) {
    super(), this.storage = e;
  }
  clear() {
    this.storage.removeItem(G);
  }
  getRecents(e) {
    var t;
    try {
      return JSON.parse((t = this.storage.getItem(G)) != null ? t : "[]").slice(0, e);
    } catch {
      return [];
    }
  }
  addOrUpdateRecent(e, t) {
    const o = [
      e,
      ...this.getRecents(t).filter((i) => i.hexcode !== e.hexcode)
    ].slice(0, t);
    try {
      this.storage.setItem(G, JSON.stringify(o));
    } catch {
      console.warn("storage is not available, recent emojis will not be saved");
    }
  }
};
var zt = class extends Ie {
  constructor() {
    super(qe() ? localStorage : $e());
  }
};
var Lt = {
  dataStore: Le,
  theme: ot,
  animate: true,
  showCategoryTabs: true,
  showPreview: true,
  showRecents: true,
  showSearch: true,
  showVariants: true,
  emojisPerRow: 8,
  visibleRows: 6,
  emojiVersion: "auto",
  i18n: ze,
  locale: "en",
  maxRecents: 50,
  custom: []
};
function $t(s = {}) {
  return {
    ...Lt,
    ...s,
    renderer: s.renderer || new Ft(),
    recentsProvider: s.recentsProvider || new zt()
  };
}
var v;
var C;
var D;
var z;
var oe;
var le = class {
  constructor() {
    f(this, C);
    f(this, z);
    f(this, v, /* @__PURE__ */ new Map());
  }
  on(e, t, o) {
    g(this, z, oe).call(this, e, t, o);
  }
  once(e, t, o) {
    g(this, z, oe).call(this, e, t, o, true);
  }
  off(e, t) {
    const o = g(this, C, D).call(this, e);
    y(this, v).set(e, o.filter((i) => i.handler !== t));
  }
  emit(e, ...t) {
    g(this, C, D).call(this, e).forEach((i) => {
      i.handler.apply(i.context, t), i.once && this.off(e, i.handler);
    });
  }
  removeAll() {
    y(this, v).clear();
  }
};
v = /* @__PURE__ */ new WeakMap(), C = /* @__PURE__ */ new WeakSet(), D = function(e) {
  return y(this, v).has(e) || y(this, v).set(e, []), y(this, v).get(e);
}, z = /* @__PURE__ */ new WeakSet(), oe = function(e, t, o, i = false) {
  g(this, C, D).call(this, e).push({ context: o, handler: t, once: i });
};
var At = {
  injectStyles: true
};
var It = class extends le {
};
var Tt = class extends le {
};
var ie = p(
  "emojiCategory",
  "categoryName",
  "noRecents",
  "recentEmojis"
);
var he = class extends c {
  constructor({ template: e, category: t, showVariants: o, lazyLoader: i }) {
    super({ template: e, classes: ie }), this.baseUIElements = {
      categoryName: c.byClass(ie.categoryName)
    }, this.category = t, this.showVariants = o, this.lazyLoader = i;
  }
  setActive(e, t, o) {
    this.emojiContainer.setActive(e, t, o);
  }
};
var Rt = new u(({ classes: s, emoji: e }) => `
  <button
    type="button"
    class="${s.emojiButton}"
    title="${e.label}"
    data-emoji="${e.emoji}"
    tabindex="-1">
    <div data-placeholder="emojiContent"></div>
  </button>
`);
var Mt = p("emojiButton");
var Te = class extends c {
  constructor({ emoji: e, lazyLoader: t, category: o }) {
    super({ template: Rt, classes: Mt }), this.emoji = e, this.lazyLoader = t, this.category = o;
  }
  initialize() {
    this.uiEvents = [
      c.uiEvent("focus", this.handleFocus)
    ], super.initialize();
  }
  handleFocus() {
    this.category && this.events.emit("focus:change", this.category);
  }
  activateFocus(e) {
    this.el.tabIndex = 0, e && this.el.focus();
  }
  deactivateFocus() {
    this.el.tabIndex = -1;
  }
  renderSync() {
    return super.renderSync({
      emoji: this.emoji,
      emojiContent: this.renderer.doRender(this.emoji, this.lazyLoader)
    });
  }
};
var Vt = class {
  constructor(e, t, o = 0, i = 0, r = false) {
    this.events = new le(), this.keyHandlers = {
      ArrowLeft: this.focusPrevious.bind(this),
      ArrowRight: this.focusNext.bind(this),
      ArrowUp: this.focusUp.bind(this),
      ArrowDown: this.focusDown.bind(this)
    }, this.rowCount = Math.ceil(t / e), this.columnCount = e, this.focusedRow = o, this.focusedColumn = i, this.emojiCount = t, this.wrap = r, this.handleKeyDown = this.handleKeyDown.bind(this);
  }
  destroy() {
    this.events.removeAll();
  }
  on(e, t) {
    this.events.on(e, t);
  }
  handleKeyDown(e) {
    e.key in this.keyHandlers && (e.preventDefault(), this.keyHandlers[e.key]());
  }
  setCell(e, t, o = true) {
    const i = this.getIndex();
    this.focusedRow = e, t !== void 0 && (this.focusedColumn = Math.min(this.columnCount, t)), (this.focusedRow >= this.rowCount || this.getIndex() >= this.emojiCount) && (this.focusedRow = this.rowCount - 1, this.focusedColumn = this.emojiCount % this.columnCount - 1), this.events.emit("focus:change", { from: i, to: this.getIndex(), performFocus: o });
  }
  setFocusedIndex(e, t = true) {
    const o = Math.floor(e / this.columnCount), i = e % this.columnCount;
    this.setCell(o, i, t);
  }
  focusNext() {
    this.focusedColumn < this.columnCount - 1 && this.getIndex() < this.emojiCount - 1 ? this.setCell(this.focusedRow, this.focusedColumn + 1) : this.focusedRow < this.rowCount - 1 ? this.setCell(this.focusedRow + 1, 0) : this.wrap ? this.setCell(0, 0) : this.events.emit("focus:overflow", 0);
  }
  focusPrevious() {
    this.focusedColumn > 0 ? this.setCell(this.focusedRow, this.focusedColumn - 1) : this.focusedRow > 0 ? this.setCell(this.focusedRow - 1, this.columnCount - 1) : this.wrap ? this.setCell(this.rowCount - 1, this.columnCount - 1) : this.events.emit("focus:underflow", this.columnCount - 1);
  }
  focusUp() {
    this.focusedRow > 0 ? this.setCell(this.focusedRow - 1, this.focusedColumn) : this.events.emit("focus:underflow", this.focusedColumn);
  }
  focusDown() {
    this.focusedRow < this.rowCount - 1 ? this.setCell(this.focusedRow + 1, this.focusedColumn) : this.events.emit("focus:overflow", this.focusedColumn);
  }
  focusToIndex(e) {
    this.setCell(Math.floor(e / this.columnCount), e % this.columnCount);
  }
  getIndex() {
    return this.focusedRow * this.columnCount + this.focusedColumn;
  }
  getCell() {
    return { row: this.focusedRow, column: this.focusedColumn };
  }
  getRowCount() {
    return this.rowCount;
  }
};
var Dt = new u(({ classes: s }) => `
  <div class="${s.emojiContainer}">
    <div data-placeholder="emojis"></div>
  </div>
`);
var Bt = p("emojiContainer");
var $ = class extends c {
  constructor({ emojis: e, showVariants: t, preview: o = true, lazyLoader: i, category: r, fullHeight: a = false }) {
    super({ template: Dt, classes: Bt }), this.fullHeight = false, this.showVariants = t, this.lazyLoader = i, this.preview = o, this.emojis = e, this.category = r, this.fullHeight = a, this.setFocus = this.setFocus.bind(this), this.triggerNextCategory = this.triggerNextCategory.bind(this), this.triggerPreviousCategory = this.triggerPreviousCategory.bind(this);
  }
  initialize() {
    this.grid = new Vt(this.options.emojisPerRow, this.emojiCount, 0, 0, !this.category), this.grid.on("focus:change", this.setFocus), this.grid.on("focus:overflow", this.triggerNextCategory), this.grid.on("focus:underflow", this.triggerPreviousCategory), this.uiEvents = [
      c.uiEvent("click", this.selectEmoji),
      c.uiEvent("keydown", this.grid.handleKeyDown)
    ], this.preview && this.uiEvents.push(
      c.uiEvent("mouseover", this.showPreview),
      c.uiEvent("mouseout", this.hidePreview),
      c.uiEvent("focus", this.showPreview, { capture: true }),
      c.uiEvent("blur", this.hidePreview, { capture: true })
    ), super.initialize();
  }
  setFocusedView(e, t) {
    if (!!e)
      if (typeof e == "string") {
        const o = this.emojis.findIndex((i) => i.emoji === e);
        this.grid.setFocusedIndex(o, false), setTimeout(() => {
          var n, l, m, d;
          const i = this.emojiViews[o].el;
          i.scrollIntoView();
          const r = (n = i.parentElement) == null ? void 0 : n.previousElementSibling, a = (m = (l = i.parentElement) == null ? void 0 : l.parentElement) == null ? void 0 : m.parentElement;
          a.scrollTop -= (d = r == null ? void 0 : r.offsetHeight) != null ? d : 0;
        });
      } else
        e.row === "first" || e.row === 0 ? this.grid.setCell(0, e.offset, t) : e.row === "last" && this.grid.setCell(this.grid.getRowCount() - 1, e.offset, t);
  }
  setActive(e, t, o) {
    var i;
    e ? this.setFocusedView(t, o) : (i = this.emojiViews[this.grid.getIndex()]) == null || i.deactivateFocus();
  }
  renderSync() {
    return this.emojiViews = this.emojis.map(
      (e) => this.viewFactory.create(Te, {
        emoji: e,
        category: this.category,
        lazyLoader: this.lazyLoader,
        renderer: this.renderer
      })
    ), this.emojiElements = this.emojiViews.map((e) => e.renderSync()), super.renderSync({
      emojis: this.emojiElements,
      i18n: this.i18n
    });
  }
  destroy() {
    super.destroy(), this.emojiViews.forEach((e) => e.destroy()), this.grid.destroy();
  }
  triggerPreviousCategory(e) {
    this.events.emit("category:previous", e);
  }
  triggerNextCategory(e) {
    this.category && this.events.emit("category:next", e);
  }
  setFocus({ from: e, to: t, performFocus: o }) {
    var i, r;
    (i = this.emojiViews[e]) == null || i.deactivateFocus(), (r = this.emojiViews[t]) == null || r.activateFocus(o);
  }
  selectEmoji(e) {
    e.stopPropagation();
    const t = q(e, this.emojis);
    t && this.events.emit("emoji:select", {
      emoji: t,
      showVariants: this.showVariants
    });
  }
  showPreview(e) {
    const o = e.target.closest("button"), i = o == null ? void 0 : o.firstElementChild, r = q(e, this.emojis);
    r && this.events.emit("preview:show", r, i == null ? void 0 : i.cloneNode(true));
  }
  hidePreview(e) {
    q(e, this.emojis) && this.events.emit("preview:hide");
  }
  get emojiCount() {
    return this.emojis.length;
  }
};
var Nt = new u(({ classes: s, category: e, pickerId: t, icon: o, i18n: i }) => `
  <section class="${s.emojiCategory}" role="tabpanel" aria-labelledby="${t}-category-${e.key}">
    <h3 data-category="${e.key}" class="${s.categoryName}">
      <i data-icon="${o}"></i>
      ${i.get(`categories.${e.key}`, e.message || e.key)}
    </h3>
    <div data-view="emojis" data-render="sync"></div>
  </section>
`);
var Ot = class extends he {
  constructor({ category: e, showVariants: t, lazyLoader: o, emojiVersion: i }) {
    super({ category: e, showVariants: t, lazyLoader: o, template: Nt }), this.showVariants = t, this.lazyLoader = o, this.emojiVersion = i;
  }
  initialize() {
    this.uiElements = { ...this.baseUIElements }, super.initialize();
  }
  async render() {
    await this.emojiDataPromise;
    const e = await this.emojiData.getEmojis(this.category, this.emojiVersion);
    return this.emojiContainer = this.viewFactory.create($, {
      emojis: e,
      showVariants: this.showVariants,
      lazyLoader: this.lazyLoader,
      category: this.category.key
    }), super.render({
      category: this.category,
      emojis: this.emojiContainer,
      emojiCount: e.length,
      icon: O[this.category.key]
    });
  }
};
var Ht = class extends $ {
  constructor({ category: e, emojis: t, preview: o = true, lazyLoader: i }) {
    super({ category: e, emojis: t, showVariants: false, preview: o, lazyLoader: i });
  }
  async addOrUpdate(e) {
    const t = this.el.querySelector(`[data-emoji="${e.emoji}"]`);
    t && (this.el.removeChild(t), this.emojis = this.emojis.filter((i) => i !== e));
    const o = this.viewFactory.create(Te, { emoji: e });
    if (this.el.insertBefore(o.renderSync(), this.el.firstChild), this.emojis = [
      e,
      ...this.emojis.filter((i) => i !== e)
    ], this.emojis.length > this.options.maxRecents) {
      this.emojis = this.emojis.slice(0, this.options.maxRecents);
      const i = this.el.childElementCount - this.options.maxRecents;
      for (let r = 0; r < i; r++)
        this.el.lastElementChild && this.el.removeChild(this.el.lastElementChild);
    }
  }
};
var Kt = new u(({ emojiCount: s, classes: e, category: t, pickerId: o, icon: i, i18n: r }) => `
  <section class="${e.emojiCategory}" role="tabpanel" aria-labelledby="${o}-category-${t.key}">
    <h3 data-category="${t.key}" class="${e.categoryName}">
      <i data-icon="${i}"></i>
      ${r.get(`categories.${t.key}`, t.message || t.key)}
    </h3>
    <div data-empty="${s === 0}" class="${e.recentEmojis}">
      <div data-view="emojis" data-render="sync"></div>
    </div>
    <div class="${e.noRecents}">
      ${r.get("recents.none")}
    </div>
  </section>
`, { mode: "async" });
var Ut = class extends he {
  constructor({ category: e, lazyLoader: t, provider: o }) {
    super({ category: e, showVariants: false, lazyLoader: t, template: Kt }), this.provider = o;
  }
  initialize() {
    this.uiElements = {
      ...this.baseUIElements,
      recents: c.byClass(ie.recentEmojis)
    }, this.appEvents = {
      "recent:add": this.addRecent
    }, super.initialize();
  }
  async addRecent(e) {
    await this.emojiContainer.addOrUpdate(e), this.ui.recents.dataset.empty = "false";
  }
  async render() {
    var t;
    const e = (t = this.provider) == null ? void 0 : t.getRecents(this.options.maxRecents);
    return this.emojiContainer = this.viewFactory.create(Ht, {
      emojis: e,
      showVariants: false,
      lazyLoader: this.lazyLoader,
      category: this.category.key
    }), await super.render({
      category: this.category,
      emojis: this.emojiContainer,
      emojiCount: e.length,
      icon: O[this.category.key]
    }), this.el;
  }
};
var qt = new u(({ classes: s, category: e, pickerId: t, icon: o, i18n: i }) => `
  <section class="${s.emojiCategory}" role="tabpanel" aria-labelledby="${t}-category-${e.key}">
    <h3 data-category="${e.key}" class="${s.categoryName}">
      <i data-icon="${o}"></i>
      ${i.get(`categories.${e.key}`, e.message || e.key)}
    </h3>
    <div data-view="emojis" data-render="sync"></div>
  </section>
`);
var Wt = class extends he {
  constructor({ category: e, lazyLoader: t }) {
    super({ template: qt, showVariants: false, lazyLoader: t, category: e });
  }
  initialize() {
    this.uiElements = { ...this.baseUIElements }, super.initialize();
  }
  async render() {
    return this.emojiContainer = this.viewFactory.create($, {
      emojis: this.customEmojis,
      showVariants: this.showVariants,
      lazyLoader: this.lazyLoader,
      category: this.category.key
    }), super.render({
      category: this.category,
      emojis: this.emojiContainer,
      emojiCount: this.customEmojis.length,
      icon: O[this.category.key]
    });
  }
};
var Re = class {
  constructor() {
    this.elements = /* @__PURE__ */ new Map();
  }
  lazyLoad(e, t) {
    return this.elements.set(e, t), e;
  }
  observe(e) {
    if (window.IntersectionObserver) {
      const t = new IntersectionObserver(
        (o) => {
          o.filter((i) => i.intersectionRatio > 0).map((i) => i.target).forEach((i) => {
            const r = this.elements.get(i);
            r == null || r(), t.unobserve(i);
          });
        },
        {
          root: e
        }
      );
      this.elements.forEach((o, i) => {
        t.observe(i);
      });
    } else
      this.elements.forEach((t) => {
        t();
      });
  }
};
var ye = p("emojiArea");
var Gt = new u(({ classes: s }) => `
  <div class="${s.emojiArea}">
    <div data-placeholder="emojis"></div>
  </div>
`, { mode: "async" });
var Jt = {
  recents: Ut,
  custom: Wt
};
function Zt(s) {
  return Jt[s.key] || Ot;
}
function Yt(s) {
  return !s || s === "button" ? {
    row: "first",
    offset: 0
  } : s;
}
var Qt = class extends c {
  constructor({ categoryTabs: e, categories: t, emojiVersion: o }) {
    super({ template: Gt, classes: ye }), this.selectedCategory = 0, this.scrollListenerState = "active", this.lazyLoader = new Re(), this.categoryTabs = e, this.categories = t, this.emojiVersion = o, this.handleScroll = He(this.handleScroll.bind(this), 100);
  }
  initialize() {
    this.appEvents = {
      "category:select": this.handleCategorySelect,
      "category:previous": this.focusPreviousCategory,
      "category:next": this.focusNextCategory,
      "focus:change": this.updateFocusedCategory
    }, this.uiElements = { emojis: c.byClass(ye.emojiArea) }, this.uiEvents = [c.uiEvent("scroll", this.handleScroll)], super.initialize();
  }
  get focusableEmoji() {
    return this.el.querySelector('[tabindex="0"]');
  }
  async render() {
    this.emojiCategories = this.categories.map(this.createCategory, this);
    const e = {};
    return this.categories.forEach((t, o) => {
      e[`emojis-${t.key}`] = this.emojiCategories[o];
    }), await super.render({
      emojis: await Promise.all(this.emojiCategories.map((t) => t.render()))
    }), this.lazyLoader.observe(this.el), this.el;
  }
  destroy() {
    super.destroy(), this.emojiCategories.forEach((e) => {
      var t;
      (t = this.observer) == null || t.unobserve(e.el), e.destroy();
    });
  }
  handleCategorySelect(e, t) {
    this.el.style.overflow = "hidden", this.selectCategory(e, t), this.el.style.overflow = "auto";
  }
  createCategory(e) {
    const t = Zt(e);
    return this.viewFactory.create(t, {
      category: e,
      showVariants: true,
      lazyLoader: this.lazyLoader,
      emojiVersion: this.emojiVersion,
      provider: this.options.recentsProvider
    });
  }
  determineInitialCategory() {
    var e;
    return this.options.initialCategory && this.categories.find((t) => t.key === this.options.initialCategory) ? this.options.initialCategory : (e = this.categories.find((t) => t.key !== "recents")) == null ? void 0 : e.key;
  }
  determineFocusTarget(e) {
    const t = this.emojiCategories.find((o) => o.category.key === e);
    return this.options.initialEmoji && (t == null ? void 0 : t.el.querySelector(`[data-emoji="${this.options.initialEmoji}"]`)) ? this.options.initialEmoji : "button";
  }
  reset(e = true) {
    this.events.emit("preview:hide");
    const t = this.determineInitialCategory();
    t && (this.selectCategory(t, {
      focus: this.determineFocusTarget(t),
      performFocus: e,
      scroll: "jump"
    }), this.selectedCategory = this.getCategoryIndex(t));
  }
  getCategoryIndex(e) {
    return this.categories.findIndex((t) => t.key === e);
  }
  focusPreviousCategory(e) {
    this.selectedCategory > 0 && this.focusCategory(this.selectedCategory - 1, { row: "last", offset: e != null ? e : this.options.emojisPerRow });
  }
  focusNextCategory(e) {
    this.selectedCategory < this.categories.length - 1 && this.focusCategory(this.selectedCategory + 1, { row: "first", offset: e != null ? e : 0 });
  }
  focusCategory(e, t) {
    this.selectCategory(e, {
      focus: t,
      performFocus: true
    });
  }
  async selectCategory(e, t = {}) {
    var l;
    this.scrollListenerState = "suspend";
    const { focus: o, performFocus: i, scroll: r } = {
      performFocus: false,
      ...t
    };
    this.emojiCategories[this.selectedCategory].setActive(false);
    const a = this.selectedCategory = typeof e == "number" ? e : this.getCategoryIndex(e);
    (l = this.categoryTabs) == null || l.setActiveTab(this.selectedCategory, {
      performFocus: i,
      scroll: o === "button"
    });
    const n = this.emojiCategories[a].el.offsetTop;
    this.emojiCategories[a].setActive(true, Yt(o), o !== "button" && i), r && (this.el.scrollTop = n), this.scrollListenerState = "resume";
  }
  updateFocusedCategory(e) {
    var t;
    this.categories[this.selectedCategory].key !== e && (this.scrollListenerState = "suspend", this.selectedCategory = this.getCategoryIndex(e), (t = this.categoryTabs) == null || t.setActiveTab(this.selectedCategory, {
      changeFocusable: false,
      performFocus: false
    }), this.scrollListenerState = "resume");
  }
  handleScroll() {
    if (this.scrollListenerState === "suspend" || !this.categoryTabs)
      return;
    if (this.scrollListenerState === "resume") {
      this.scrollListenerState = "active";
      return;
    }
    const e = this.el.scrollTop, t = this.el.scrollHeight - this.el.offsetHeight, o = this.emojiCategories.findIndex((r, a) => {
      var n;
      return e < ((n = this.emojiCategories[a + 1]) == null ? void 0 : n.el.offsetTop);
    }), i = {
      changeFocusable: false,
      performFocus: false,
      scroll: false
    };
    e === 0 ? this.categoryTabs.setActiveTab(0, i) : Math.floor(e) === Math.floor(t) || o < 0 ? this.categoryTabs.setActiveTab(this.categories.length - 1, i) : this.categoryTabs.setActiveTab(o, i);
  }
};
var Xt = new u(({ classList: s, classes: e, icon: t, message: o }) => `
<div class="${s}" role="alert">
  <div class="${e.iconContainer}"><i data-size="10x" data-icon="${t}"></i></div>
  <h3 class="${e.title}">${o}</h3>
</div>
`);
var fe = p("error", "iconContainer", "title");
var re = class extends c {
  constructor({ message: e, icon: t = "warning", template: o = Xt, className: i }) {
    super({ template: o, classes: fe }), this.message = e, this.icon = t, this.className = i;
  }
  renderSync() {
    const e = [fe.error, this.className].join(" ").trim();
    return super.renderSync({ message: this.message, icon: this.icon, classList: e });
  }
};
var es = new u(({ classList: s, classes: e, icon: t, i18n: o, message: i }) => `
  <div class="${s}" role="alert">
    <div class="${e.icon}"><i data-size="10x" data-icon="${t}"></i></div>
    <h3 class="${e.title}">${i}</h3>
    <button type="button">${o.get("retry")}</button>
  </div>
`);
var ts = p("dataError");
var ss = class extends re {
  constructor({ message: e }) {
    super({ message: e, template: es, className: ts.dataError });
  }
  initialize() {
    this.uiElements = { retryButton: "button" }, this.uiEvents = [c.childEvent("retryButton", "click", this.onRetry)], super.initialize();
  }
  async onRetry() {
    this.emojiData ? await this.emojiData.delete() : await this.options.dataStore.deleteDatabase(this.options.locale), this.events.emit("reinitialize");
    const e = await ce(this.options.locale, this.options.dataStore, this.options.messages, this.options.emojiData, this.emojiData);
    this.viewFactory.setEmojiData(e), this.events.emit("data:ready", e);
  }
};
var j = p(
  "preview",
  "previewEmoji",
  "previewName",
  "tagList",
  "tag"
);
var os = new u(({ classes: s, tag: e }) => `
  <li class="${s.tag}">${e}</li>
`);
var is = new u(({ classes: s }) => `
  <div class="${s.preview}">
    <div class="${s.previewEmoji}"></div>
    <div class="${s.previewName}"></div>
    <ul class="${s.tagList}"></ul>
  </div>
`);
var rs = class extends c {
  constructor() {
    super({ template: is, classes: j });
  }
  initialize() {
    this.uiElements = {
      emoji: c.byClass(j.previewEmoji),
      name: c.byClass(j.previewName),
      tagList: c.byClass(j.tagList)
    }, this.appEvents = {
      "preview:show": this.showPreview,
      "preview:hide": this.hidePreview
    }, super.initialize();
  }
  showPreview(e, t) {
    if (w(this.ui.emoji, t), this.ui.name.textContent = e.label, e.tags) {
      this.ui.tagList.style.display = "flex";
      const o = e.tags.map((i) => os.renderSync({ tag: i, classes: j }));
      w(this.ui.tagList, ...o);
    }
  }
  hidePreview() {
    V(this.ui.emoji), V(this.ui.name), V(this.ui.tagList);
  }
};
var as = new u(({ classes: s, i18n: e }) => `
  <button title="${e.get("search.clear")}" class="${s.clearSearchButton}">
    <i data-icon="xmark"></i>
  </button>
`);
var ns = new u(({ classes: s, i18n: e }) => `
<div class="${s.searchContainer}">
  <input class="${s.searchField}" placeholder="${e.get("search")}">
  <span class="${s.searchAccessory}"></span>
</div>
`, { mode: "async" });
var _ = p(
  "searchContainer",
  "searchField",
  "clearButton",
  "searchAccessory",
  "clearSearchButton",
  "notFound"
);
var cs = class extends c {
  constructor({ categories: e, emojiVersion: t }) {
    super({ template: ns, classes: _ }), this.categories = e.filter((o) => o.key !== "recents"), this.emojiVersion = t, this.search = Ke(this.search.bind(this), 100);
  }
  initialize() {
    this.uiElements = {
      searchField: c.byClass(_.searchField),
      searchAccessory: c.byClass(_.searchAccessory)
    }, this.uiEvents = [
      c.childEvent("searchField", "keydown", this.onKeyDown),
      c.childEvent("searchField", "input", this.onSearchInput)
    ], super.initialize();
  }
  async render() {
    return await super.render(), this.searchIcon = Pe("search"), this.notFoundMessage = this.viewFactory.create(re, {
      message: this.i18n.get("search.notFound"),
      className: _.notFound,
      icon: "sad"
    }), this.notFoundMessage.renderSync(), this.errorMessage = this.viewFactory.create(re, { message: this.i18n.get("search.error") }), this.errorMessage.renderSync(), this.clearSearchButton = as.render({
      classes: _,
      i18n: this.i18n
    }), this.clearSearchButton.addEventListener("click", (e) => this.onClearSearch(e)), this.searchField = this.ui.searchField, this.showSearchIcon(), this.el;
  }
  showSearchIcon() {
    this.showSearchAccessory(this.searchIcon);
  }
  showClearSearchButton() {
    this.showSearchAccessory(this.clearSearchButton);
  }
  showSearchAccessory(e) {
    w(this.ui.searchAccessory, e);
  }
  clear() {
    this.searchField.value = "", this.showSearchIcon();
  }
  focus() {
    this.searchField.focus();
  }
  onClearSearch(e) {
    var t;
    e.stopPropagation(), this.searchField.value = "", (t = this.resultsContainer) == null || t.destroy(), this.resultsContainer = null, this.showSearchIcon(), this.events.emit("content:show"), this.searchField.focus();
  }
  handleResultsKeydown(e) {
    this.resultsContainer && e.key === "Escape" && this.onClearSearch(e);
  }
  onKeyDown(e) {
    var t;
    e.key === "Escape" && this.searchField.value ? this.onClearSearch(e) : (e.key === "Enter" || e.key === "ArrowDown") && this.resultsContainer && (e.preventDefault(), (t = this.resultsContainer.el.querySelector('[tabindex="0"]')) == null || t.focus());
  }
  onSearchInput(e) {
    this.searchField.value ? (this.showClearSearchButton(), this.search()) : this.onClearSearch(e);
  }
  async search() {
    var e;
    if (!!this.searchField.value)
      try {
        const t = await this.emojiData.searchEmojis(
          this.searchField.value,
          this.customEmojis,
          this.emojiVersion,
          this.categories
        );
        if (this.events.emit("preview:hide"), t.length) {
          const o = new Re();
          this.resultsContainer = this.viewFactory.create($, {
            emojis: t,
            fullHeight: true,
            showVariants: true,
            lazyLoader: o
          }), this.resultsContainer.renderSync(), (e = this.resultsContainer) != null && e.el && (o.observe(this.resultsContainer.el), this.resultsContainer.setActive(true, { row: 0, offset: 0 }, false), this.resultsContainer.el.addEventListener("keydown", (i) => this.handleResultsKeydown(i)), this.events.emit("content:show", this.resultsContainer));
        } else
          this.events.emit("content:show", this.notFoundMessage);
      } catch {
        this.events.emit("content:show", this.errorMessage);
      }
  }
};
var ls = new u(({ classes: s }) => `
  <div class="${s.variantOverlay}">
    <div class="${s.variantPopup}">
      <div data-view="emojis" data-render="sync"></div>
    </div>
  </div>
`);
var ve = p(
  "variantOverlay",
  "variantPopup"
);
var J = {
  easing: "ease-in-out",
  duration: 250,
  fill: "both"
};
var we = {
  opacity: [0, 1]
};
var be = {
  opacity: [0, 1],
  transform: ["scale3d(0.8, 0.8, 0.8)", "scale3d(1, 1, 1)"]
};
var hs = class extends c {
  constructor({ emoji: e, parent: t }) {
    super({ template: ls, classes: ve, parent: t }), this.focusedEmojiIndex = 0, this.focusTrap = new st(), this.animateShow = () => Promise.all([
      I(this.el, we, J, this.options),
      I(this.ui.popup, be, J, this.options)
    ]), this.emoji = e;
  }
  initialize() {
    this.uiElements = {
      popup: c.byClass(ve.variantPopup)
    }, this.uiEvents = [
      c.uiEvent("click", this.handleClick),
      c.uiEvent("keydown", this.handleKeydown)
    ], super.initialize();
  }
  animateHide() {
    const e = { ...J, direction: "reverse" };
    return Promise.all([
      I(this.el, we, e, this.options),
      I(this.ui.popup, be, e, this.options)
    ]);
  }
  async hide() {
    await this.animateHide(), this.events.emit("variantPopup:hide");
  }
  handleKeydown(e) {
    e.key === "Escape" && (this.hide(), e.stopPropagation());
  }
  handleClick(e) {
    this.ui.popup.contains(e.target) || this.hide();
  }
  getEmoji(e) {
    return this.renderedEmojis[e];
  }
  setFocusedEmoji(e) {
    const t = this.getEmoji(this.focusedEmojiIndex);
    t.tabIndex = -1, this.focusedEmojiIndex = e;
    const o = this.getEmoji(this.focusedEmojiIndex);
    o.tabIndex = 0, o.focus();
  }
  destroy() {
    this.emojiContainer.destroy(), this.focusTrap.deactivate(), super.destroy();
  }
  renderSync() {
    const e = {
      ...this.emoji,
      skins: null
    }, t = (this.emoji.skins || []).map((i) => ({
      ...i,
      label: this.emoji.label,
      tags: this.emoji.tags
    })), o = [e, ...t];
    return this.emojiContainer = this.viewFactory.create($, {
      emojis: o,
      preview: false
    }), super.renderSync({ emojis: this.emojiContainer }), o.length < this.options.emojisPerRow && this.el.style.setProperty("--emojis-per-row", o.length.toString()), this.el;
  }
  activate() {
    this.emojiContainer.setActive(true, { row: 0, offset: 0 }, true), this.focusTrap.activate(this.el);
  }
};
var ds = new u(({ classes: s, i18n: e, category: t, pickerId: o, icon: i }) => `
<li class="${s.categoryTab}">
  <button
    aria-selected="false"
    role="tab"
    class="${s.categoryButton}"
    tabindex="-1"
    title="${e.get(`categories.${t.key}`, t.message || t.key)}"
    type="button"
    data-category="${t.key}"
    id="${o}-category-${t.key}"
  >
    <i data-icon="${i}"></i>
</li>
`);
var Z = p(
  "categoryTab",
  "categoryTabActive",
  "categoryButton"
);
var ms = class extends c {
  constructor({ category: e, icon: t }) {
    super({ template: ds, classes: Z }), this.isActive = false, this.category = e, this.icon = t;
  }
  initialize() {
    this.uiElements = {
      button: c.byClass(Z.categoryButton)
    }, this.uiEvents = [
      c.childEvent("button", "click", this.selectCategory),
      c.childEvent("button", "focus", this.selectCategory)
    ], super.initialize();
  }
  renderSync() {
    return super.renderSync({
      category: this.category,
      icon: this.icon
    }), this.ui.button.ariaSelected = "false", this.el;
  }
  setActive(e, t = {}) {
    const { changeFocusable: o, performFocus: i, scroll: r } = {
      changeFocusable: true,
      performFocus: true,
      scroll: true,
      ...t
    };
    this.el.classList.toggle(Z.categoryTabActive, e), o && (this.ui.button.tabIndex = e ? 0 : -1, this.ui.button.ariaSelected = e.toString()), e && i && (this.ui.button.focus(), r && this.events.emit("category:select", this.category.key, { scroll: "animate", focus: "button", performFocus: false })), this.isActive = e;
  }
  selectCategory() {
    this.isActive || this.events.emit("category:select", this.category.key, { scroll: "animate", focus: "button", performFocus: true });
  }
};
var us = new u(({ classes: s }) => `
  <div class="${s.categoryButtonsContainer}">
    <ul role="tablist" class="${s.categoryButtons}">
      <div data-placeholder="tabs"></div>
    </ul>
  </div>
`);
var ps = p("categoryButtons", "categoryButtonsContainer");
var gs = class extends c {
  constructor({ categories: e }) {
    super({ template: us, classes: ps }), this.activeCategoryIndex = 0, this.categories = e;
  }
  initialize() {
    this.keyBindings = {
      ArrowLeft: this.stepSelectedTab(-1),
      ArrowRight: this.stepSelectedTab(1)
    }, this.uiEvents = [
      c.uiEvent("scroll", this.checkOverflow)
    ], super.initialize();
  }
  checkOverflow() {
    const e = Math.abs(this.el.scrollLeft - (this.el.scrollWidth - this.el.offsetWidth)) > 1, t = this.el.scrollLeft > 0;
    this.el.className = "categoryButtonsContainer", t && e ? this.el.classList.add("has-overflow-both") : t ? this.el.classList.add("has-overflow-left") : e && this.el.classList.add("has-overflow-right");
  }
  renderSync() {
    return this.tabViews = this.categories.map((e) => this.viewFactory.create(ms, { category: e, icon: O[e.key] })), super.renderSync({
      tabs: this.tabViews.map((e) => e.renderSync())
    }), this.el;
  }
  get currentCategory() {
    return this.categories[this.activeCategoryIndex];
  }
  get currentTabView() {
    return this.tabViews[this.activeCategoryIndex];
  }
  setActiveTab(e, t = {}) {
    this.checkOverflow();
    const o = this.currentTabView, i = this.tabViews[e];
    o.setActive(false, t), i.setActive(true, t), this.activeCategoryIndex = e;
  }
  getTargetCategory(e) {
    return e < 0 ? this.categories.length - 1 : e >= this.categories.length ? 0 : e;
  }
  stepSelectedTab(e) {
    return () => {
      const t = this.activeCategoryIndex + e;
      this.setActiveTab(this.getTargetCategory(t), {
        changeFocusable: true,
        performFocus: true
      });
    };
  }
};
var ys = [
  { version: 15, emoji: String.fromCodePoint(129768) },
  { version: 14, emoji: String.fromCodePoint(128733) },
  { version: 13, emoji: String.fromCodePoint(129729) },
  { version: 12, emoji: String.fromCodePoint(129449) },
  { version: 11, emoji: String.fromCodePoint(129463) },
  { version: 5, emoji: String.fromCodePoint(129322) },
  { version: 4, emoji: String.fromCodePoint(9877) },
  { version: 3, emoji: String.fromCodePoint(129314) },
  { version: 2, emoji: String.fromCodePoint(128488) },
  { version: 1, emoji: String.fromCodePoint(128512) }
];
function fs() {
  var e;
  const s = ys.find((t) => vs(t.emoji));
  return (e = s == null ? void 0 : s.version) != null ? e : 1;
}
function vs(s) {
  const e = document.createElement("canvas").getContext("2d");
  if (e)
    return e.textBaseline = "top", e.font = "32px Arial", e.fillText(s, 0, 0), e.getImageData(16, 16, 1, 1).data[0] !== 0;
}
function Y(s, e) {
  return Array.from({ length: s }, () => e).join("");
}
function ws({ showHeader: s, classes: e }) {
  return s ? `
    <header class="${e.header}">
      <div data-view="search"></div>
      <div data-view="categoryTabs" data-render="sync"></div>
    </header>
  ` : "";
}
function bs(s) {
  const { classes: e, theme: t, className: o = "" } = s;
  return `
    <div class="picmo__picker ${e.picker} ${t} ${o}">
      ${ws(s)}
      <div class="${e.content}">
        <div data-view="emojiArea"></div>
      </div>
      <div data-view="preview"></div>
    </div>
  `;
}
function Cs(s) {
  const { emojiCount: e, classes: t, theme: o, className: i, categoryCount: r } = s, a = ({ showSearch: d, classes: h }) => d ? `
    <div class="${h.searchSkeleton}">
      <div class="${h.searchInput} ${h.placeholder}"></div>
    </div>
  ` : "", n = ({ showCategoryTabs: d, classes: h }) => d ? `
    <div class="${h.categoryTabsSkeleton}">
      ${Y(r, `<div class="${h.placeholder} ${h.categoryTab}"></div>`)}
    </div>
  ` : "", l = ({ showHeader: d, classes: h }) => d ? `
    <header class="${h.headerSkeleton}">
      ${a(s)}
      ${n(s)}
    </header>
  ` : "", m = ({ showPreview: d, classes: h }) => d ? `
    <div class="${h.previewSkeleton}">
      <div class="${h.placeholder} ${h.previewEmoji}"></div>
      <div class="${h.placeholder} ${h.previewName}"></div>
      <ul class="${h.tagList}">
        ${Y(3, `<li class="${h.placeholder} ${h.tag}"></li>`)}
      </ul>
    </div>
  ` : "";
  return `
    <div class="picmo__picker ${t.skeleton} ${t.picker} ${o} ${i}">
      ${l(s)}
      <div class="${t.contentSkeleton}">
        <div class="${t.placeholder} ${t.categoryName}"></div>
        <div class="${t.emojiGrid}">
          ${Y(e, `<div class="${t.placeholder} ${t.emoji}"></div>`)}
        </div>
      </div>
      ${m(s)}
    </div>
  `;
}
var js = new u((s) => s.isLoaded ? bs(s) : Cs(s));
var T = p(
  "picker",
  "skeleton",
  "placeholder",
  "searchSkeleton",
  "searchInput",
  "categoryTabsSkeleton",
  "headerSkeleton",
  "categoryTab",
  "contentSkeleton",
  "categoryName",
  "emojiGrid",
  "emoji",
  "previewSkeleton",
  "previewEmoji",
  "previewName",
  "tagList",
  "tag",
  "overlay",
  "content",
  "fullHeight",
  "pluginContainer",
  "header"
);
var R = {
  emojisPerRow: "--emojis-per-row",
  visibleRows: "--row-count",
  emojiSize: "--emoji-size"
};
var _s = class extends c {
  constructor() {
    super({ template: js, classes: T }), this.pickerReady = false, this.externalEvents = new Tt(), this.updaters = {
      styleProperty: (e) => (t) => this.el.style.setProperty(R[e], t.toString()),
      theme: (e) => {
        const t = this.options.theme, o = this.el.closest(`.${t}`);
        this.el.classList.remove(t), o == null || o.classList.remove(t), this.el.classList.add(e), o == null || o.classList.add(e);
      },
      className: (e) => {
        this.options.className && this.el.classList.remove(this.options.className), this.el.classList.add(e);
      },
      emojisPerRow: this.updateStyleProperty.bind(this, "emojisPerRow"),
      emojiSize: this.updateStyleProperty.bind(this, "emojiSize"),
      visibleRows: this.updateStyleProperty.bind(this, "visibleRows")
    };
  }
  initialize() {
    this.uiElements = {
      pickerContent: c.byClass(T.content),
      header: c.byClass(T.header)
    }, this.uiEvents = [
      c.uiEvent("keydown", this.handleKeyDown)
    ], this.appEvents = {
      error: this.onError,
      reinitialize: this.reinitialize,
      "data:ready": this.onDataReady,
      "content:show": this.showContent,
      "variantPopup:hide": this.hideVariantPopup,
      "emoji:select": this.selectEmoji
    }, super.initialize(), this.options.recentsProvider;
  }
  destroy() {
    var e, t;
    super.destroy(), (e = this.search) == null || e.destroy(), this.emojiArea.destroy(), (t = this.categoryTabs) == null || t.destroy(), this.events.removeAll(), this.externalEvents.removeAll();
  }
  clearRecents() {
    this.options.recentsProvider.clear();
  }
  addEventListener(e, t) {
    this.externalEvents.on(e, t);
  }
  removeEventListener(e, t) {
    this.externalEvents.off(e, t);
  }
  initializePickerView() {
    this.pickerReady && (this.showContent(), this.emojiArea.reset(false));
  }
  handleKeyDown(e) {
    const t = e.ctrlKey || e.metaKey;
    e.key === "s" && t && this.search && (e.preventDefault(), this.search.focus());
  }
  buildChildViews() {
    return this.options.showPreview && (this.preview = this.viewFactory.create(rs)), this.options.showSearch && (this.search = this.viewFactory.create(cs, {
      categories: this.categories,
      emojiVersion: this.emojiVersion
    })), this.options.showCategoryTabs && (this.categoryTabs = this.viewFactory.create(gs, {
      categories: this.categories
    })), this.currentView = this.emojiArea = this.viewFactory.create(Qt, {
      categoryTabs: this.categoryTabs,
      categories: this.categories,
      emojiVersion: this.emojiVersion
    }), [this.preview, this.search, this.emojiArea, this.categoryTabs];
  }
  setStyleProperties() {
    this.options.showSearch || this.el.style.setProperty("--search-height-full", "0px"), this.options.showCategoryTabs || (this.el.style.setProperty("--category-tabs-height", "0px"), this.el.style.setProperty("--category-tabs-offset", "0px")), this.options.showPreview || this.el.style.setProperty("--emoji-preview-height-full", "0px"), Object.keys(R).forEach((e) => {
      this.options[e] && this.el.style.setProperty(R[e], this.options[e].toString());
    });
  }
  updateStyleProperty(e, t) {
    this.el.style.setProperty(R[e], t.toString());
  }
  reinitialize() {
    this.renderSync();
  }
  onError(e) {
    const t = this.viewFactory.createWithOptions({ data: false }, ss, { message: this.i18n.get("error.load") }), o = this.el.offsetHeight || 375;
    throw this.el.style.height = `${o}px`, w(this.el, t.renderSync()), e;
  }
  async onDataReady(e) {
    const t = this.el;
    try {
      e ? this.emojiData = e : await this.emojiDataPromise, this.options.emojiVersion === "auto" ? this.emojiVersion = fs() || parseFloat(Ve) : this.emojiVersion = this.options.emojiVersion, this.categories = await this.emojiData.getCategories(this.options);
      const [o, i, r, a] = this.buildChildViews();
      await super.render({
        isLoaded: true,
        search: i,
        categoryTabs: a,
        emojiArea: r,
        preview: o,
        showHeader: Boolean(this.search || this.categoryTabs),
        theme: this.options.theme,
        className: this.options.className
      }), this.el.style.setProperty("--category-count", this.categories.length.toString()), this.pickerReady = true, t.replaceWith(this.el), this.setStyleProperties(), this.initializePickerView(), this.setInitialFocus(), this.externalEvents.emit("data:ready");
    } catch (o) {
      this.events.emit("error", o);
    }
  }
  renderSync() {
    var t;
    let e = ((t = this.options.categories) == null ? void 0 : t.length) || 10;
    if (this.options.showRecents && (e += 1), super.renderSync({
      isLoaded: false,
      theme: this.options.theme,
      className: this.options.className,
      showSearch: this.options.showSearch,
      showPreview: this.options.showPreview,
      showCategoryTabs: this.options.showCategoryTabs,
      showHeader: this.options.showSearch || this.options.showCategoryTabs,
      emojiCount: this.options.emojisPerRow * this.options.visibleRows,
      categoryCount: e
    }), this.el.style.setProperty("--category-count", e.toString()), !this.options.rootElement)
      throw new Error("Picker must be given a root element via the rootElement option");
    return w(this.options.rootElement, this.el), this.setStyleProperties(), this.pickerReady && this.initializePickerView(), this.el;
  }
  getInitialFocusTarget() {
    if (typeof this.options.autoFocus < "u")
      switch (this.options.autoFocus) {
        case "emojis":
          return this.emojiArea.focusableEmoji;
        case "search":
          return this.search;
        case "auto":
          return this.search || this.emojiArea.focusableEmoji;
        default:
          return null;
      }
    if (this.options.autoFocusSearch === true)
      return console.warn("options.autoFocusSearch is deprecated, please use options.focusTarget instead"), this.search;
  }
  setInitialFocus() {
    var e;
    !this.pickerReady || (e = this.getInitialFocusTarget()) == null || e.focus();
  }
  reset(e = true) {
    var t;
    this.pickerReady && (this.emojiArea.reset(e), this.showContent(this.emojiArea)), (t = this.search) == null || t.clear(), this.hideVariantPopup();
  }
  showContent(e = this.emojiArea) {
    var t, o;
    e !== this.currentView && (this.currentView !== this.emojiArea && ((t = this.currentView) == null || t.destroy()), this.ui.pickerContent.classList.toggle(T.fullHeight, e !== this.emojiArea), w(this.ui.pickerContent, e.el), this.currentView = e, e === this.emojiArea ? (this.emojiArea.reset(), this.categoryTabs && this.ui.header.appendChild(this.categoryTabs.el)) : (o = this.categoryTabs) == null || o.el.remove());
  }
  hideVariantPopup() {
    var e;
    (e = this.variantPopup) == null || e.destroy();
  }
  isPickerClick(e) {
    var r, a;
    const t = e.target, o = this.el.contains(t), i = (a = (r = this.variantPopup) == null ? void 0 : r.el) == null ? void 0 : a.contains(t);
    return o || i;
  }
  async selectEmoji({ emoji: e }) {
    var t, o;
    ((t = e.skins) == null ? void 0 : t.length) && this.options.showVariants && !this.isVariantPopupOpen ? this.showVariantPopup(e) : (await ((o = this.variantPopup) == null ? void 0 : o.animateHide()), this.events.emit("variantPopup:hide"), await this.emitEmoji(e));
  }
  get isVariantPopupOpen() {
    return this.variantPopup && !this.variantPopup.isDestroyed;
  }
  async showVariantPopup(e) {
    const t = document.activeElement;
    this.events.once("variantPopup:hide", () => {
      t == null || t.focus();
    }), this.variantPopup = this.viewFactory.create(hs, { emoji: e, parent: this.el }), this.el.appendChild(this.variantPopup.renderSync()), this.variantPopup.activate();
  }
  async emitEmoji(e) {
    this.externalEvents.emit("emoji:select", await this.renderer.doEmit(e)), this.options.recentsProvider.addOrUpdateRecent(e, this.options.maxRecents), this.events.emit("recent:add", e);
  }
  updateOptions(e) {
    Object.keys(e).forEach((t) => {
      this.updaters[t](e[t]);
    }), Object.assign(this.options, e);
  }
};
var ks = class {
  constructor({ events: e, i18n: t, renderer: o, emojiData: i, options: r, customEmojis: a = [], pickerId: n }) {
    this.events = e, this.i18n = t, this.renderer = o, this.emojiData = i, this.options = r, this.customEmojis = a, this.pickerId = n;
  }
  setEmojiData(e) {
    this.emojiData = Promise.resolve(e);
  }
  createWithOptions(e = {}, t, ...o) {
    const i = new t(...o);
    return i.setPickerId(this.pickerId), i.setEvents(this.events), i.setI18n(this.i18n), i.setRenderer(this.renderer), e.data !== false && i.setEmojiData(this.emojiData), i.setOptions(this.options), i.setCustomEmojis(this.customEmojis), i.viewFactory = this, i.initialize(), i;
  }
  create(e, ...t) {
    return this.createWithOptions({}, e, ...t);
  }
};
var L;
var xs = class {
  constructor(e = {}) {
    f(this, L, void 0);
    A(this, L, new Map(Object.entries(e)));
  }
  get(e, t = e) {
    return y(this, L).get(e) || t;
  }
};
L = /* @__PURE__ */ new WeakMap();
function Es(s, e) {
  e === void 0 && (e = {});
  var t = e.insertAt;
  if (!(!s || typeof document > "u")) {
    var o = document.head || document.getElementsByTagName("head")[0], i = document.createElement("style");
    i.type = "text/css", t === "top" && o.firstChild ? o.insertBefore(i, o.firstChild) : o.appendChild(i), i.styleSheet ? i.styleSheet.cssText = s : i.appendChild(document.createTextNode(s));
  }
}
function Ss() {
  let s = false;
  return function(t) {
    At.injectStyles && !s && (Es(t), s = true);
  };
}
var Fs = `.picmo__picker .picmo__icon{width:1.25em;height:1em;fill:currentColor}.picmo__icon-small{font-size:.8em}.picmo__icon-medium{font-size:1em}.picmo__icon-large{font-size:1.25em}.picmo__icon-2x{font-size:2em}.picmo__icon-3x{font-size:3em}.picmo__icon-4x{font-size:4em}.picmo__icon-5x{font-size:5em}.picmo__icon-8x{font-size:8em}.picmo__icon-10x{font-size:10em}.picmo__light,.picmo__auto{color-scheme:light;--accent-color: #4f46e5;--background-color: #f9fafb;--border-color: #cccccc;--category-name-background-color: #f9fafb;--category-name-button-color: #999999;--category-name-text-color: hsl(214, 30%, 50%);--category-tab-active-background-color: rgba(255, 255, 255, .6);--category-tab-active-color: var(--accent-color);--category-tab-color: #666;--category-tab-highlight-background-color: rgba(0, 0, 0, .15);--error-color-dark: hsl(0, 100%, 45%);--error-color: hsl(0, 100%, 40%);--focus-indicator-background-color: hsl(198, 65%, 85%);--focus-indicator-color: #333333;--hover-background-color: #c7d2fe;--placeholder-background-color: #cccccc;--search-background-color: #f9fafb;--search-focus-background-color: #ffffff;--search-icon-color: #999999;--search-placeholder-color: #71717a;--secondary-background-color: #e2e8f0;--secondary-text-color: #666666;--tag-background-color: rgba(162, 190, 245, .3);--text-color: #000000;--variant-popup-background-color: #ffffff}.picmo__dark{color-scheme:dark;--accent-color: #A580F9;--background-color: #333333;--border-color: #666666;--category-name-background-color: #333333;--category-name-button-color: #eeeeee;--category-name-text-color: #ffffff;--category-tab-active-background-color: #000000;--category-tab-active-color: var(--accent-color);--category-tab-color: #cccccc;--category-tab-highlight-background-color: #4A4A4A;--error-color-dark: hsl(0, 7%, 3%);--error-color: hsl(0, 30%, 60%);--focus-indicator-background-color: hsl(0, 0%, 50%);--focus-indicator-color: #999999;--hover-background-color: hsla(0, 0%, 40%, .85);--image-placeholder-color: #ffffff;--placeholder-background-color: #666666;--search-background-color: #71717a;--search-focus-background-color: #52525b;--search-icon-color: #cccccc;--search-placeholder-color: #d4d4d8;--secondary-background-color: #000000;--secondary-text-color: #999999;--tag-background-color: rgba(162, 190, 245, .3);--text-color: #ffffff;--variant-popup-background-color: #333333}@media (prefers-color-scheme: dark){.picmo__auto{color-scheme:dark;--accent-color: #A580F9;--background-color: #333333;--border-color: #666666;--category-name-background-color: #333333;--category-name-button-color: #eeeeee;--category-name-text-color: #ffffff;--category-tab-active-background-color: #000000;--category-tab-active-color: var(--accent-color);--category-tab-color: #cccccc;--category-tab-highlight-background-color: #4A4A4A;--error-color-dark: hsl(0, 7%, 3%);--error-color: hsl(0, 30%, 60%);--focus-indicator-background-color: hsl(0, 0%, 50%);--focus-indicator-color: #999999;--hover-background-color: hsla(0, 0%, 40%, .85);--image-placeholder-color: #ffffff;--placeholder-background-color: #666666;--search-background-color: #71717a;--search-focus-background-color: #52525b;--search-icon-color: #cccccc;--search-placeholder-color: #d4d4d8;--secondary-background-color: #000000;--secondary-text-color: #999999;--tag-background-color: rgba(162, 190, 245, .3);--text-color: #ffffff;--variant-popup-background-color: #333333}}.picmo__picker .picmo__categoryButtonsContainer{overflow:auto;padding:2px 0}.picmo__picker .picmo__categoryButtonsContainer.picmo__has-overflow-right{mask-image:linear-gradient(270deg,rgba(255,255,255,0) 0%,rgba(255,255,255,1) 10%);-webkit-mask-image:linear-gradient(270deg,rgba(255,255,255,0) 0%,rgba(255,255,255,1) 10%)}.picmo__picker .picmo__categoryButtonsContainer.picmo__has-overflow-left{mask-image:linear-gradient(90deg,rgba(255,255,255,0) 0%,rgba(255,255,255,1) 10%);-webkit-mask-image:linear-gradient(90deg,rgba(255,255,255,0) 0%,rgba(255,255,255,1) 10%)}.picmo__picker .picmo__categoryButtonsContainer.picmo__has-overflow-both{mask-image:linear-gradient(90deg,rgba(255,255,255,0) 0%,rgba(255,255,255,1) 10%,rgba(255,255,255,1) 90%,rgba(255,255,255,0) 100%);-webkit-mask-image:linear-gradient(90deg,rgba(255,255,255,0) 0%,rgba(255,255,255,1) 10%,rgba(255,255,255,1) 90%,rgba(255,255,255,0) 100%)}.picmo__picker .picmo__categoryButtons{display:flex;flex-direction:row;gap:var(--tab-gap);margin:0;padding:0 .5em;align-items:center;height:var(--category-tabs-height);box-sizing:border-box;width:100%;justify-content:space-between;position:relative;list-style-type:none;justify-self:center;max-width:min(23.55rem,calc(var(--category-count, 1) * 2.5rem))}.picmo__picker .picmo__categoryButtons .picmo__categoryTab{display:flex;align-items:center;transition:all .1s;width:2em}.picmo__picker .picmo__categoryButtons .picmo__categoryTab.picmo__categoryTabActive .picmo__categoryButton{color:var(--category-tab-active-color);background:linear-gradient(rgba(255,255,255,.75) 0%,rgba(255,255,255,.75) 100%),linear-gradient(var(--category-tab-active-color) 0%,var(--category-tab-active-color) 100%);border:2px solid var(--category-tab-active-color)}.picmo__picker .picmo__categoryButtons .picmo__categoryTab.picmo__categoryTabActive .picmo__categoryButton:hover{background-color:var(--category-tab-active-background-color)}.picmo__picker .picmo__categoryButtons .picmo__categoryTab button.picmo__categoryButton{border-radius:5px;background:transparent;border:2px solid transparent;color:var(--category-tab-color);cursor:pointer;padding:2px;vertical-align:middle;display:flex;align-items:center;justify-content:center;font-size:1.2rem;width:1.6em;height:1.6em;transition:all .1s}.picmo__picker .picmo__categoryButtons .picmo__categoryTab button.picmo__categoryButton:is(img){width:var(--category-tab-size);height:var(--category-tab-size)}.picmo__picker .picmo__categoryButtons .picmo__categoryTab button.picmo__categoryButton:hover{background:var(--category-tab-highlight-background-color)}.picmo__dataError [data-icon]{opacity:.8}@keyframes appear{0%{opacity:0}to{opacity:.8}}@keyframes appear-grow{0%{opacity:0;transform:scale(.8)}to{opacity:.8;transform:scale(1)}}.picmo__picker .picmo__error{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;color:var(--secondary-text-color)}.picmo__picker .picmo__error .picmo__iconContainer{opacity:.8;animation:appear-grow .25s cubic-bezier(.175,.885,.32,1.275);--color-primary: var(--error-color);--color-secondary: var(--error-color-dark)}.picmo__picker .picmo__error .picmo__title{animation:appear .25s;animation-delay:50ms;animation-fill-mode:both}.picmo__picker .picmo__error button{padding:8px 16px;cursor:pointer;background:var(--background-color);border:1px solid var(--text-color);border-radius:5px;color:var(--text-color)}.picmo__picker .picmo__error button:hover{background:var(--text-color);color:var(--background-color)}.picmo__emojiButton{background:transparent;border:none;border-radius:15px;cursor:pointer;display:flex;font-family:var(--emoji-font);font-size:var(--emoji-size);height:100%;justify-content:center;align-items:center;margin:0;overflow:hidden;padding:0;width:100%}.picmo__emojiButton:hover{background:var(--hover-background-color)}.picmo__emojiButton:focus{border-radius:0;background:var(--focus-indicator-background-color);outline:1px solid var(--focus-indicator-color)}.picmo__picker .picmo__emojiArea{height:var(--emoji-area-height);overflow-y:auto;position:relative}.picmo__picker .picmo__emojiCategory{position:relative}.picmo__picker .picmo__emojiCategory .picmo__categoryName{font-size:.9em;padding:.5rem;margin:0;background:var(--category-name-background-color);color:var(--category-name-text-color);top:0;z-index:1;display:grid;gap:4px;grid-template-columns:auto 1fr auto;align-items:center;line-height:1;box-sizing:border-box;height:var(--category-name-height);justify-content:flex-start;text-transform:uppercase}.picmo__picker .picmo__emojiCategory .picmo__categoryName button{background:transparent;border:none;display:flex;align-items:center;cursor:pointer;color:var(--category-name-button-color)}.picmo__picker .picmo__emojiCategory .picmo__categoryName button:hover{opacity:1}.picmo__picker .picmo__emojiCategory .picmo__noRecents{color:var(--secondary-text-color);grid-column:1 / span var(--emojis-per-row);font-size:.9em;text-align:center;display:flex;align-items:center;justify-content:center;min-height:calc(var(--emoji-size) * var(--emoji-size-multiplier))}.picmo__picker .picmo__emojiCategory .picmo__recentEmojis[data-empty=true]{display:none}:is(.picmo__picker .picmo__emojiCategory) .picmo__recentEmojis[data-empty=false]+div{display:none}.picmo__picker .picmo__emojiContainer{display:grid;justify-content:space-between;gap:1px;padding:0 .5em;grid-template-columns:repeat(var(--emojis-per-row),calc(var(--emoji-size) * var(--emoji-size-multiplier)));grid-auto-rows:calc(var(--emoji-size) * var(--emoji-size-multiplier));align-items:center;justify-items:center}.picmo__picker.picmo__picker{--border-radius: 5px;--emoji-area-height: calc( (var(--row-count) * var(--emoji-size) * var(--emoji-size-multiplier)) + var(--category-name-height) );--content-height: var(--emoji-area-height);--emojis-per-row: 8;--row-count: 6;--emoji-preview-margin: 4px;--emoji-preview-height: calc(var(--emoji-preview-size) + 1em + 1px);--emoji-preview-height-full: calc(var(--emoji-preview-height) + var(--emoji-preview-margin));--emoji-preview-size: 2.75em;--emoji-size: 2rem;--emoji-size-multiplier: 1.3;--content-margin: 8px;--category-tabs-height:calc(1.5em + 9px);--category-tabs-offset: 8px;--category-tab-size: 1.2rem;--category-name-height: 2rem;--category-name-padding-y: 6px;--search-height: 2em;--search-margin: .5em;--search-margin-bottom: 4px;--search-height-full: calc(var(--search-height) + var(--search-margin) + var(--search-margin-bottom));--overlay-background-color: rgba(0, 0, 0, .8);--emoji-font: "Segoe UI Emoji", "Segoe UI Symbol", "Segoe UI", "Apple Color Emoji", "Twemoji Mozilla", "Noto Color Emoji", "EmojiOne Color", "Android Emoji";--ui-font: -apple-system, BlinkMacSystemFont, "Helvetica Neue", sans-serif;--ui-font-size: 16px;--picker-width: calc(var(--emojis-per-row) * var(--emoji-size) * var(--emoji-size-multiplier) + 2.75rem);--preview-background-color: var(--secondary-background-color);background:var(--background-color);border-radius:var(--border-radius);border:1px solid var(--border-color);font-family:var(--ui-font);font-size:var(--ui-font-size);overflow:hidden;position:relative;width:var(--picker-width);display:grid;gap:8px}.picmo__picker.picmo__picker>*{font-family:var(--ui-font)}.picmo__picker.picmo__skeleton{background:var(--background-color);border-radius:var(--border-radius);border:1px solid var(--border-color);font-family:var(--ui-font);width:var(--picker-width);color:var(--secondary-text-color)}.picmo__picker.picmo__skeleton *{box-sizing:border-box}.picmo__picker.picmo__skeleton .picmo__placeholder{background:var(--placeholder-background-color);position:relative;overflow:hidden}.picmo__picker.picmo__skeleton .picmo__placeholder:after{position:absolute;top:0;right:0;bottom:0;left:0;transform:translate(-100%);background-image:linear-gradient(90deg,rgba(255,255,255,0) 0,rgba(255,255,255,.2) 20%,rgba(255,255,255,.5) 60%,rgba(255,255,255,0) 100%);animation:shine 2s infinite;content:""}.picmo__picker.picmo__skeleton .picmo__headerSkeleton{background-color:var(--secondary-background-color);padding-top:8px;padding-bottom:8px;display:flex;flex-direction:column;overflow:hidden;gap:8px;border-bottom:1px solid var(--border-color);width:var(--picker-width)}.picmo__picker.picmo__skeleton .picmo__searchSkeleton{padding:0 8px;height:var(--search-height)}.picmo__picker.picmo__skeleton .picmo__searchSkeleton .picmo__searchInput{width:100%;height:28px;border-radius:3px}.picmo__picker.picmo__skeleton .picmo__categoryTabsSkeleton{height:var(--category-tabs-height);display:flex;flex-direction:row;align-items:center;justify-self:center;width:calc(2rem * var(--category-count, 1))}.picmo__picker.picmo__skeleton .picmo__categoryTabsSkeleton .picmo__categoryTab{width:25px;height:25px;padding:2px;border-radius:5px;margin:.25em}.picmo__picker.picmo__skeleton .picmo__contentSkeleton{height:var(--content-height);padding-right:8px;opacity:.7}.picmo__picker.picmo__skeleton .picmo__contentSkeleton .picmo__categoryName{width:50%;height:1rem;margin:.5rem;box-sizing:border-box}.picmo__picker.picmo__skeleton .picmo__contentSkeleton .picmo__emojiGrid{display:grid;justify-content:space-between;gap:1px;padding:0 .5em;grid-template-columns:repeat(var(--emojis-per-row),calc(var(--emoji-size) * var(--emoji-size-multiplier)));grid-auto-rows:calc(var(--emoji-size) * var(--emoji-size-multiplier));align-items:center;justify-items:center;width:var(--picker-width)}.picmo__picker.picmo__skeleton .picmo__contentSkeleton .picmo__emojiGrid .picmo__emoji{width:var(--emoji-size);height:var(--emoji-size);border-radius:50%}.picmo__picker.picmo__skeleton .picmo__previewSkeleton{height:var(--emoji-preview-height);border-top:1px solid var(--border-color);display:grid;align-items:center;padding:.5em;gap:6px;grid-template-columns:auto 1fr;grid-template-rows:auto 1fr;grid-template-areas:"emoji name" "emoji tags"}.picmo__picker.picmo__skeleton .picmo__previewSkeleton .picmo__previewEmoji{grid-area:emoji;border-radius:50%;width:var(--emoji-preview-size);height:var(--emoji-preview-size)}.picmo__picker.picmo__skeleton .picmo__previewSkeleton .picmo__previewName{grid-area:name;height:.8em;width:80%}.picmo__picker.picmo__skeleton .picmo__previewSkeleton .picmo__tagList{grid-area:tags;list-style-type:none;display:flex;flex-direction:row;padding:0;margin:0}.picmo__picker.picmo__skeleton .picmo__previewSkeleton .picmo__tagList .picmo__tag{border-radius:3px;padding:2px 8px;margin-right:.25em;height:1em;width:20%}.picmo__overlay{background:rgba(0,0,0,.75);height:100%;left:0;position:fixed;top:0;width:100%;z-index:1000}.picmo__content{position:relative;overflow:hidden;height:var(--content-height)}.picmo__content.picmo__fullHeight{height:calc(var(--content-height) + var(--category-tabs-height) + var(--category-tabs-offset));overflow-y:auto}.picmo__pluginContainer{margin:.5em;display:flex;flex-direction:row}.picmo__header{background-color:var(--secondary-background-color);padding-top:8px;padding-bottom:8px;display:grid;gap:8px;border-bottom:1px solid var(--border-color)}@media (prefers-reduced-motion: reduce){.picmo__placeholder{background:var(--placeholder-background-color);position:relative;overflow:hidden}.picmo__placeholder:after{display:none}}.picmo__picker .picmo__preview{border-top:1px solid var(--border-color);display:grid;align-items:center;gap:6px;grid-template-columns:auto 1fr;grid-template-rows:auto 1fr;grid-template-areas:"emoji name" "emoji tags";height:var(--emoji-preview-height);box-sizing:border-box;padding:.5em;position:relative;background:var(--preview-background-color)}.picmo__picker .picmo__preview .picmo__previewEmoji{grid-area:emoji;font-size:var(--emoji-preview-size);font-family:var(--emoji-font);width:1.25em;display:flex;align-items:center;justify-content:center}.picmo__picker .picmo__preview .picmo__previewName{grid-area:name;color:var(--text-color);font-size:.8em;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-weight:500}.picmo__picker .picmo__preview .picmo__tagList{grid-area:tags;list-style-type:none;display:flex;flex-direction:row;padding:0;margin:0;font-size:.75em;overflow:hidden}.picmo__picker .picmo__preview .picmo__tag{border-radius:3px;background:var(--tag-background-color);color:var(--text-color);padding:2px 8px;margin-right:.25em;white-space:nowrap}.picmo__picker .picmo__preview .picmo__tag:last-child{margin-right:0}.picmo__picker .picmo__searchContainer{display:flex;height:var(--search-height);box-sizing:border-box;padding:0 8px;position:relative}.picmo__picker .picmo__searchContainer .picmo__searchField{background:var(--search-background-color);border-radius:3px;border:none;box-sizing:border-box;color:var(--text-color);font-size:.9em;outline:none;padding:.5em 2.25em .5em .5em;width:100%}.picmo__picker .picmo__searchContainer .picmo__searchField:focus{background:var(--search-focus-background-color)}.picmo__picker .picmo__searchContainer .picmo__searchField::placeholder{color:var(--search-placeholder-color)}.picmo__picker .picmo__searchContainer .picmo__searchAccessory{color:var(--search-icon-color);height:100%;position:absolute;right:1em;top:0;width:1.25rem;display:flex;align-items:center}.picmo__picker .picmo__searchContainer .picmo__searchAccessory svg{fill:var(--search-icon-color)}.picmo__picker .picmo__searchContainer .picmo__clearButton{border:0;color:var(--search-icon-color);background:transparent;cursor:pointer}.picmo__picker .picmo__searchContainer .picmo__clearSearchButton{cursor:pointer;border:none;background:transparent;color:var(--search-icon-color);font-size:1em;width:100%;height:100%;display:flex;align-items:center;padding:0}.picmo__picker .picmo__searchContainer .picmo__notFound [data-icon]{fill:#f3e265}.picmo__picker .picmo__variantOverlay{background:var(--overlay-background-color);border-radius:5px;display:flex;flex-direction:column;height:100%;justify-content:center;left:0;position:absolute;top:0;width:100%;z-index:1}.picmo__picker .picmo__variantOverlay .picmo__variantPopup{background:var(--variant-popup-background-color);border-radius:5px;margin:.5em;padding:.5em;text-align:center;user-select:none;display:flex;align-items:center;justify-content:center}.picmo__customEmoji{width:1em;height:1em}@keyframes shine{to{transform:translate(100%)}}.picmo__picker .picmo__imagePlaceholder{width:2rem;height:2rem;border-radius:50%}.picmo__placeholder{background:#DDDBDD;position:relative}.picmo__placeholder:after{position:absolute;top:0;right:0;bottom:0;left:0;transform:translate(-100%);background-image:linear-gradient(90deg,rgba(255,255,255,0) 0,rgba(255,255,255,.2) 20%,rgba(255,255,255,.5) 60%,rgba(255,255,255,0) 100%);animation:shine 2s infinite;content:""}
`;
function Ps(s) {
  return ce(s.locale, s.dataStore, s.messages, s.emojiData);
}
var zs = 0;
var M;
function Ls() {
  return `picmo-${Date.now()}-${zs++}`;
}
var $s = Ss();
function Hs(s) {
  $s(Fs);
  const e = $t(s), t = ((e == null ? void 0 : e.custom) || []).map((n) => ({
    ...n,
    custom: true,
    tags: ["custom", ...n.tags || []]
  })), o = new It();
  M || (M = Ps(e));
  const i = new xs(e.i18n);
  M.then((n) => {
    o.emit("data:ready", n);
  }).catch((n) => {
    o.emit("error", n);
  });
  const a = new ks({
    events: o,
    i18n: i,
    customEmojis: t,
    renderer: e.renderer,
    options: e,
    emojiData: M,
    pickerId: Ls()
  }).create(_s);
  return a.renderSync(), a;
}
var As = {
  "categories.activities": "Aktivitäten",
  "categories.animals-nature": "Tiere & Natur",
  "categories.custom": "Benutzerdefiniert",
  "categories.flags": "Flaggen",
  "categories.food-drink": "Essen & Trinken",
  "categories.objects": "Gegenstände",
  "categories.people-body": "Mensch & Körper",
  "categories.recents": "Zuletzt genutzt",
  "categories.smileys-emotion": "Smileys & Emotionen",
  "categories.symbols": "Symbole",
  "categories.travel-places": "Reisen & Orte",
  "error.load": "Emojis wurden nicht geladen",
  "recents.clear": "Zuletzt genutzte Emojis löschen",
  "recents.none": "Kein Emoji ausgewählt.",
  retry: "Erneut versuchen",
  "search.clear": "Suche löschen",
  "search.error": "Suche erfolglos",
  "search.notFound": "Kein Emoji gefunden",
  search: "Emojis durchsuchen ..."
};
var Is = {
  "categories.activities": "Aktiviteetit",
  "categories.animals-nature": "Eläimet & luonto",
  "categories.custom": "Mukautettu",
  "categories.flags": "Liput",
  "categories.food-drink": "Ruoka & juoma",
  "categories.objects": "Esineet",
  "categories.people-body": "Ihmiset & keho",
  "categories.recents": "Viimeksi käytetty",
  "categories.smileys-emotion": "Hymiöt & tunne",
  "categories.symbols": "Symbolit",
  "categories.travel-places": "Matkustus & paikat",
  "error.load": "Emojien lataaminen epäonnistui",
  "recents.clear": "Tyhjennä viimeksi käytetyt emojit",
  "recents.none": "Et ole valinnut vielä emojia.",
  retry: "Kokeile uudestaan",
  "search.clear": "Tyhjennä haku",
  "search.error": "Emojien etsiminen epäonnistui",
  "search.notFound": "Emojia ei löytynyt",
  search: "Etsi emojia..."
};
var Ts = {
  "categories.activities": "Activités",
  "categories.animals-nature": "Animaux et nature",
  "categories.custom": "Personnalisé",
  "categories.flags": "Drapeaux",
  "categories.food-drink": "Nourriture et boissons",
  "categories.objects": "Objets",
  "categories.people-body": "Personnes et corps",
  "categories.recents": "Récemment utilisé",
  "categories.smileys-emotion": "Visages et émotions",
  "categories.symbols": "Symboles",
  "categories.travel-places": "Voyages et lieux",
  "error.load": "Échec du chargement des émojis",
  "recents.clear": "Effacez les émojis récents",
  "recents.none": "Vous n'avez pas encore sélectionné d'émojis.",
  retry: "Essayez à nouveau",
  "search.clear": "Effacer la recherche",
  "search.error": "Échec de la recherche d'émojis",
  "search.notFound": "Aucun émoji trouvé",
  search: "Rechercher des émojis..."
};
var Rs = {
  "categories.activities": "Activiteiten",
  "categories.animals-nature": "Dieren & Natuur",
  "categories.custom": "Aangepast",
  "categories.flags": "Vlaggen",
  "categories.food-drink": "Eten & Drinken",
  "categories.objects": "Voorwerpen",
  "categories.people-body": "Mens & Lichaam",
  "categories.recents": "Laatst gebruikt",
  "categories.smileys-emotion": "Smileys en emoties",
  "categories.symbols": "Symbolen",
  "categories.travel-places": "Reizen & Plaatsen",
  "error.load": "Kan emoji's niet laden",
  "recents.clear": "Wis recente emoji's",
  "recents.none": "Geen emoji geselecteerd.",
  retry: "Probeer het nog eens",
  "search.clear": "Zoekopdracht wissen",
  "search.error": "Zoeken mislukt",
  "search.notFound": "Geen emoji gevonden",
  search: "Zoek emoji..."
};
var Ms = {
  "categories.activities": "Aktiviteter",
  "categories.animals-nature": "Dyr & natur",
  "categories.custom": "Tilpasset",
  "categories.flags": "Flagg",
  "categories.food-drink": "Mat & drikke",
  "categories.objects": "Objekter",
  "categories.people-body": "Mennesker & kropp",
  "categories.recents": "Nylig brukte",
  "categories.smileys-emotion": "Smilefjes & følelser",
  "categories.symbols": "Symboler",
  "categories.travel-places": "Reise & steder",
  "error.load": "Klarte ikke laste inn emojis",
  "recents.clear": "Fjern nylige emojis",
  "recents.none": "Du har ikke valgt noen emojis enda.",
  retry: "Prøv igjen",
  "search.clear": "Tøm søk",
  "search.error": "Klarte ikke å søke etter emojis",
  "search.notFound": "Ingen emojis funnet",
  search: "Søk etter emojis..."
};
var Vs = {
  "categories.activities": "Aktiviteter",
  "categories.animals-nature": "Djur & natur",
  "categories.custom": "Anpassad",
  "categories.flags": "Flagga",
  "categories.food-drink": "Mat & dryck",
  "categories.objects": "Objekt",
  "categories.people-body": "Människor & kropp",
  "categories.recents": "Nyligen använd",
  "categories.smileys-emotion": "Humör & känslor",
  "categories.symbols": "Symboler",
  "categories.travel-places": "Resor & platser",
  "error.load": "Det gick inte att ladda emojis",
  "recents.clear": "Ta bort de senaste emojis",
  "recents.none": "Du har inte valt några emojis än",
  retry: "Försök igen",
  "search.clear": "Tom sökning",
  "search.error": "Det gick inte att söka efter emojis",
  "search.notFound": "Inga emojis hittades",
  search: "Sök efter emojis..."
};
var Ks = Object.freeze(Object.defineProperty({
  __proto__: null,
  de: As,
  en: ze,
  fi: Is,
  fr: Ts,
  nl: Rs,
  no: Ms,
  sv: Vs
}, Symbol.toStringTag, { value: "Module" }));

// node_modules/@picmo/popup-picker/dist/index.js
function _2(t) {
  return t.split("-")[0];
}
function V2(t) {
  return t.split("-")[1];
}
function K(t) {
  return ["top", "bottom"].includes(_2(t)) ? "x" : "y";
}
function at2(t) {
  return t === "y" ? "height" : "width";
}
function tt2(t, e, n) {
  let {
    reference: i,
    floating: o
  } = t;
  const c2 = i.x + i.width / 2 - o.width / 2, r = i.y + i.height / 2 - o.height / 2, s = K(e), l = at2(s), a = i[l] / 2 - o[l] / 2, d = _2(e), f2 = s === "x";
  let u2;
  switch (d) {
    case "top":
      u2 = {
        x: c2,
        y: i.y - o.height
      };
      break;
    case "bottom":
      u2 = {
        x: c2,
        y: i.y + i.height
      };
      break;
    case "right":
      u2 = {
        x: i.x + i.width,
        y: r
      };
      break;
    case "left":
      u2 = {
        x: i.x - o.width,
        y: r
      };
      break;
    default:
      u2 = {
        x: i.x,
        y: i.y
      };
  }
  switch (V2(e)) {
    case "start":
      u2[s] -= a * (n && f2 ? -1 : 1);
      break;
    case "end":
      u2[s] += a * (n && f2 ? -1 : 1);
      break;
  }
  return u2;
}
var At2 = async (t, e, n) => {
  const {
    placement: i = "bottom",
    strategy: o = "absolute",
    middleware: c2 = [],
    platform: r
  } = n, s = await (r.isRTL == null ? void 0 : r.isRTL(e));
  let l = await r.getElementRects({
    reference: t,
    floating: e,
    strategy: o
  }), {
    x: a,
    y: d
  } = tt2(l, i, s), f2 = i, u2 = {}, h = 0;
  for (let m = 0; m < c2.length; m++) {
    const {
      name: p2,
      fn: w2
    } = c2[m], {
      x: y2,
      y: g2,
      data: v2,
      reset: x2
    } = await w2({
      x: a,
      y: d,
      initialPlacement: i,
      placement: f2,
      strategy: o,
      middlewareData: u2,
      rects: l,
      platform: r,
      elements: {
        reference: t,
        floating: e
      }
    });
    if (a = y2 != null ? y2 : a, d = g2 != null ? g2 : d, u2 = {
      ...u2,
      [p2]: {
        ...u2[p2],
        ...v2
      }
    }, x2 && h <= 50) {
      h++, typeof x2 == "object" && (x2.placement && (f2 = x2.placement), x2.rects && (l = x2.rects === true ? await r.getElementRects({
        reference: t,
        floating: e,
        strategy: o
      }) : x2.rects), {
        x: a,
        y: d
      } = tt2(l, f2, s)), m = -1;
      continue;
    }
  }
  return {
    x: a,
    y: d,
    placement: f2,
    strategy: o,
    middlewareData: u2
  };
};
function Lt2(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function Ot2(t) {
  return typeof t != "number" ? Lt2(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function I2(t) {
  return {
    ...t,
    top: t.y,
    left: t.x,
    right: t.x + t.width,
    bottom: t.y + t.height
  };
}
async function Q2(t, e) {
  var n;
  e === void 0 && (e = {});
  const {
    x: i,
    y: o,
    platform: c2,
    rects: r,
    elements: s,
    strategy: l
  } = t, {
    boundary: a = "clippingAncestors",
    rootBoundary: d = "viewport",
    elementContext: f2 = "floating",
    altBoundary: u2 = false,
    padding: h = 0
  } = e, m = Ot2(h), w2 = s[u2 ? f2 === "floating" ? "reference" : "floating" : f2], y2 = I2(await c2.getClippingRect({
    element: (n = await (c2.isElement == null ? void 0 : c2.isElement(w2))) == null || n ? w2 : w2.contextElement || await (c2.getDocumentElement == null ? void 0 : c2.getDocumentElement(s.floating)),
    boundary: a,
    rootBoundary: d,
    strategy: l
  })), g2 = I2(c2.convertOffsetParentRelativeRectToViewportRelativeRect ? await c2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: f2 === "floating" ? {
      ...r.floating,
      x: i,
      y: o
    } : r.reference,
    offsetParent: await (c2.getOffsetParent == null ? void 0 : c2.getOffsetParent(s.floating)),
    strategy: l
  }) : r[f2]);
  return {
    top: y2.top - g2.top + m.top,
    bottom: g2.bottom - y2.bottom + m.bottom,
    left: y2.left - g2.left + m.left,
    right: g2.right - y2.right + m.right
  };
}
var Rt2 = Math.min;
var kt2 = Math.max;
function et2(t, e, n) {
  return kt2(t, Rt2(e, n));
}
var Tt2 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function z2(t) {
  return t.replace(/left|right|bottom|top/g, (e) => Tt2[e]);
}
function ft2(t, e, n) {
  n === void 0 && (n = false);
  const i = V2(t), o = K(t), c2 = at2(o);
  let r = o === "x" ? i === (n ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top";
  return e.reference[c2] > e.floating[c2] && (r = z2(r)), {
    main: r,
    cross: z2(r)
  };
}
var Bt2 = {
  start: "end",
  end: "start"
};
function G2(t) {
  return t.replace(/start|end/g, (e) => Bt2[e]);
}
var St2 = ["top", "right", "bottom", "left"];
var Dt2 = St2.reduce((t, e) => t.concat(e, e + "-start", e + "-end"), []);
function _t2(t, e, n) {
  return (t ? [...n.filter((o) => V2(o) === t), ...n.filter((o) => V2(o) !== t)] : n.filter((o) => _2(o) === o)).filter((o) => t ? V2(o) === t || (e ? G2(o) !== o : false) : true);
}
var Vt2 = function(t) {
  return t === void 0 && (t = {}), {
    name: "autoPlacement",
    options: t,
    async fn(e) {
      var n, i, o, c2, r;
      const {
        x: s,
        y: l,
        rects: a,
        middlewareData: d,
        placement: f2,
        platform: u2,
        elements: h
      } = e, {
        alignment: m = null,
        allowedPlacements: p2 = Dt2,
        autoAlignment: w2 = true,
        ...y2
      } = t, g2 = _t2(m, w2, p2), v2 = await Q2(e, y2), x2 = (n = (i = d.autoPlacement) == null ? void 0 : i.index) != null ? n : 0, b2 = g2[x2];
      if (b2 == null)
        return {};
      const {
        main: M2,
        cross: H
      } = ft2(b2, a, await (u2.isRTL == null ? void 0 : u2.isRTL(h.floating)));
      if (f2 !== b2)
        return {
          x: s,
          y: l,
          reset: {
            placement: g2[0]
          }
        };
      const j2 = [v2[_2(b2)], v2[M2], v2[H]], E2 = [...(o = (c2 = d.autoPlacement) == null ? void 0 : c2.overflows) != null ? o : [], {
        placement: b2,
        overflows: j2
      }], B2 = g2[x2 + 1];
      if (B2)
        return {
          data: {
            index: x2 + 1,
            overflows: E2
          },
          reset: {
            placement: B2
          }
        };
      const S2 = E2.slice().sort((A2, $2) => A2.overflows[0] - $2.overflows[0]), F2 = (r = S2.find((A2) => {
        let {
          overflows: $2
        } = A2;
        return $2.every((yt2) => yt2 <= 0);
      })) == null ? void 0 : r.placement, D2 = F2 != null ? F2 : S2[0].placement;
      return D2 !== f2 ? {
        data: {
          index: x2 + 1,
          overflows: E2
        },
        reset: {
          placement: D2
        }
      } : {};
    }
  };
};
function Nt2(t) {
  const e = z2(t);
  return [G2(t), e, G2(e)];
}
var Ft2 = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var n;
      const {
        placement: i,
        middlewareData: o,
        rects: c2,
        initialPlacement: r,
        platform: s,
        elements: l
      } = e, {
        mainAxis: a = true,
        crossAxis: d = true,
        fallbackPlacements: f2,
        fallbackStrategy: u2 = "bestFit",
        flipAlignment: h = true,
        ...m
      } = t, p2 = _2(i), y2 = f2 || (p2 === r || !h ? [z2(r)] : Nt2(r)), g2 = [r, ...y2], v2 = await Q2(e, m), x2 = [];
      let b2 = ((n = o.flip) == null ? void 0 : n.overflows) || [];
      if (a && x2.push(v2[p2]), d) {
        const {
          main: E2,
          cross: B2
        } = ft2(i, c2, await (s.isRTL == null ? void 0 : s.isRTL(l.floating)));
        x2.push(v2[E2], v2[B2]);
      }
      if (b2 = [...b2, {
        placement: i,
        overflows: x2
      }], !x2.every((E2) => E2 <= 0)) {
        var M2, H;
        const E2 = ((M2 = (H = o.flip) == null ? void 0 : H.index) != null ? M2 : 0) + 1, B2 = g2[E2];
        if (B2)
          return {
            data: {
              index: E2,
              overflows: b2
            },
            reset: {
              placement: B2
            }
          };
        let S2 = "bottom";
        switch (u2) {
          case "bestFit": {
            var j2;
            const F2 = (j2 = b2.map((D2) => [D2, D2.overflows.filter((A2) => A2 > 0).reduce((A2, $2) => A2 + $2, 0)]).sort((D2, A2) => D2[1] - A2[1])[0]) == null ? void 0 : j2[0].placement;
            F2 && (S2 = F2);
            break;
          }
          case "initialPlacement":
            S2 = r;
            break;
        }
        if (i !== S2)
          return {
            reset: {
              placement: S2
            }
          };
      }
      return {};
    }
  };
};
async function $t2(t, e) {
  const {
    placement: n,
    platform: i,
    elements: o
  } = t, c2 = await (i.isRTL == null ? void 0 : i.isRTL(o.floating)), r = _2(n), s = V2(n), l = K(n) === "x", a = ["left", "top"].includes(r) ? -1 : 1, d = c2 && l ? -1 : 1, f2 = typeof e == "function" ? e(t) : e;
  let {
    mainAxis: u2,
    crossAxis: h,
    alignmentAxis: m
  } = typeof f2 == "number" ? {
    mainAxis: f2,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...f2
  };
  return s && typeof m == "number" && (h = s === "end" ? m * -1 : m), l ? {
    x: h * d,
    y: u2 * a
  } : {
    x: u2 * a,
    y: h * d
  };
}
var nt2 = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      const {
        x: n,
        y: i
      } = e, o = await $t2(e, t);
      return {
        x: n + o.x,
        y: i + o.y,
        data: o
      };
    }
  };
};
function Wt2(t) {
  return t === "x" ? "y" : "x";
}
var ot2 = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: n,
        y: i,
        placement: o
      } = e, {
        mainAxis: c2 = true,
        crossAxis: r = false,
        limiter: s = {
          fn: (w2) => {
            let {
              x: y2,
              y: g2
            } = w2;
            return {
              x: y2,
              y: g2
            };
          }
        },
        ...l
      } = t, a = {
        x: n,
        y: i
      }, d = await Q2(e, l), f2 = K(_2(o)), u2 = Wt2(f2);
      let h = a[f2], m = a[u2];
      if (c2) {
        const w2 = f2 === "y" ? "top" : "left", y2 = f2 === "y" ? "bottom" : "right", g2 = h + d[w2], v2 = h - d[y2];
        h = et2(g2, h, v2);
      }
      if (r) {
        const w2 = u2 === "y" ? "top" : "left", y2 = u2 === "y" ? "bottom" : "right", g2 = m + d[w2], v2 = m - d[y2];
        m = et2(g2, m, v2);
      }
      const p2 = s.fn({
        ...e,
        [f2]: h,
        [u2]: m
      });
      return {
        ...p2,
        data: {
          x: p2.x - n,
          y: p2.y - i
        }
      };
    }
  };
};
function ut2(t) {
  return t && t.document && t.location && t.alert && t.setInterval;
}
function R2(t) {
  if (t == null)
    return window;
  if (!ut2(t)) {
    const e = t.ownerDocument;
    return e && e.defaultView || window;
  }
  return t;
}
function C2(t) {
  return R2(t).getComputedStyle(t);
}
function L2(t) {
  return ut2(t) ? "" : t ? (t.nodeName || "").toLowerCase() : "";
}
function dt2() {
  const t = navigator.userAgentData;
  return t != null && t.brands ? t.brands.map((e) => e.brand + "/" + e.version).join(" ") : navigator.userAgent;
}
function P2(t) {
  return t instanceof R2(t).HTMLElement;
}
function k2(t) {
  return t instanceof R2(t).Element;
}
function Mt2(t) {
  return t instanceof R2(t).Node;
}
function N2(t) {
  if (typeof ShadowRoot > "u")
    return false;
  const e = R2(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function U2(t) {
  const {
    overflow: e,
    overflowX: n,
    overflowY: i
  } = C2(t);
  return /auto|scroll|overlay|hidden/.test(e + i + n);
}
function Ht2(t) {
  return ["table", "td", "th"].includes(L2(t));
}
function pt2(t) {
  const e = /firefox/i.test(dt2()), n = C2(t);
  return n.transform !== "none" || n.perspective !== "none" || n.contain === "paint" || ["transform", "perspective"].includes(n.willChange) || e && n.willChange === "filter" || e && (n.filter ? n.filter !== "none" : false);
}
function ht2() {
  return !/^((?!chrome|android).)*safari/i.test(dt2());
}
var it2 = Math.min;
var W2 = Math.max;
var X2 = Math.round;
function O2(t, e, n) {
  var i, o, c2, r;
  e === void 0 && (e = false), n === void 0 && (n = false);
  const s = t.getBoundingClientRect();
  let l = 1, a = 1;
  e && P2(t) && (l = t.offsetWidth > 0 && X2(s.width) / t.offsetWidth || 1, a = t.offsetHeight > 0 && X2(s.height) / t.offsetHeight || 1);
  const d = k2(t) ? R2(t) : window, f2 = !ht2() && n, u2 = (s.left + (f2 && (i = (o = d.visualViewport) == null ? void 0 : o.offsetLeft) != null ? i : 0)) / l, h = (s.top + (f2 && (c2 = (r = d.visualViewport) == null ? void 0 : r.offsetTop) != null ? c2 : 0)) / a, m = s.width / l, p2 = s.height / a;
  return {
    width: m,
    height: p2,
    top: h,
    right: u2 + m,
    bottom: h + p2,
    left: u2,
    x: u2,
    y: h
  };
}
function T2(t) {
  return ((Mt2(t) ? t.ownerDocument : t.document) || window.document).documentElement;
}
function q2(t) {
  return k2(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.pageXOffset,
    scrollTop: t.pageYOffset
  };
}
function mt2(t) {
  return O2(T2(t)).left + q2(t).scrollLeft;
}
function jt2(t) {
  const e = O2(t);
  return X2(e.width) !== t.offsetWidth || X2(e.height) !== t.offsetHeight;
}
function It2(t, e, n) {
  const i = P2(e), o = T2(e), c2 = O2(
    t,
    i && jt2(e),
    n === "fixed"
  );
  let r = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const s = {
    x: 0,
    y: 0
  };
  if (i || !i && n !== "fixed")
    if ((L2(e) !== "body" || U2(o)) && (r = q2(e)), P2(e)) {
      const l = O2(e, true);
      s.x = l.x + e.clientLeft, s.y = l.y + e.clientTop;
    } else
      o && (s.x = mt2(o));
  return {
    x: c2.left + r.scrollLeft - s.x,
    y: c2.top + r.scrollTop - s.y,
    width: c2.width,
    height: c2.height
  };
}
function gt2(t) {
  return L2(t) === "html" ? t : t.assignedSlot || t.parentNode || (N2(t) ? t.host : null) || T2(t);
}
function st2(t) {
  return !P2(t) || C2(t).position === "fixed" ? null : zt2(t);
}
function zt2(t) {
  let {
    offsetParent: e
  } = t, n = t, i = false;
  for (; n && n !== e; ) {
    const {
      assignedSlot: o
    } = n;
    if (o) {
      let c2 = o.offsetParent;
      if (C2(o).display === "contents") {
        const r = o.hasAttribute("style"), s = o.style.display;
        o.style.display = C2(n).display, c2 = o.offsetParent, o.style.display = s, r || o.removeAttribute("style");
      }
      n = o, e !== c2 && (e = c2, i = true);
    } else if (N2(n) && n.host && i)
      break;
    n = N2(n) && n.host || n.parentNode;
  }
  return e;
}
function Xt2(t) {
  let e = gt2(t);
  for (N2(e) && (e = e.host); P2(e) && !["html", "body"].includes(L2(e)); ) {
    if (pt2(e))
      return e;
    {
      const n = e.parentNode;
      e = N2(n) ? n.host : n;
    }
  }
  return null;
}
function J2(t) {
  const e = R2(t);
  let n = st2(t);
  for (; n && Ht2(n) && C2(n).position === "static"; )
    n = st2(n);
  return n && (L2(n) === "html" || L2(n) === "body" && C2(n).position === "static" && !pt2(n)) ? e : n || Xt2(t) || e;
}
function rt2(t) {
  if (P2(t))
    return {
      width: t.offsetWidth,
      height: t.offsetHeight
    };
  const e = O2(t);
  return {
    width: e.width,
    height: e.height
  };
}
function Yt2(t) {
  let {
    rect: e,
    offsetParent: n,
    strategy: i
  } = t;
  const o = P2(n), c2 = T2(n);
  if (n === c2)
    return e;
  let r = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const s = {
    x: 0,
    y: 0
  };
  if ((o || !o && i !== "fixed") && ((L2(n) !== "body" || U2(c2)) && (r = q2(n)), P2(n))) {
    const l = O2(n, true);
    s.x = l.x + n.clientLeft, s.y = l.y + n.clientTop;
  }
  return {
    ...e,
    x: e.x - r.scrollLeft + s.x,
    y: e.y - r.scrollTop + s.y
  };
}
function Kt2(t, e) {
  const n = R2(t), i = T2(t), o = n.visualViewport;
  let c2 = i.clientWidth, r = i.clientHeight, s = 0, l = 0;
  if (o) {
    c2 = o.width, r = o.height;
    const a = ht2();
    (a || !a && e === "fixed") && (s = o.offsetLeft, l = o.offsetTop);
  }
  return {
    width: c2,
    height: r,
    x: s,
    y: l
  };
}
function Ut2(t) {
  var e;
  const n = T2(t), i = q2(t), o = (e = t.ownerDocument) == null ? void 0 : e.body, c2 = W2(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), r = W2(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0);
  let s = -i.scrollLeft + mt2(t);
  const l = -i.scrollTop;
  return C2(o || n).direction === "rtl" && (s += W2(n.clientWidth, o ? o.clientWidth : 0) - c2), {
    width: c2,
    height: r,
    x: s,
    y: l
  };
}
function wt2(t) {
  const e = gt2(t);
  return ["html", "body", "#document"].includes(L2(e)) ? t.ownerDocument.body : P2(e) && U2(e) ? e : wt2(e);
}
function Y2(t, e) {
  var n;
  e === void 0 && (e = []);
  const i = wt2(t), o = i === ((n = t.ownerDocument) == null ? void 0 : n.body), c2 = R2(i), r = o ? [c2].concat(c2.visualViewport || [], U2(i) ? i : []) : i, s = e.concat(r);
  return o ? s : s.concat(Y2(r));
}
function qt2(t, e) {
  const n = e.getRootNode == null ? void 0 : e.getRootNode();
  if (t.contains(e))
    return true;
  if (n && N2(n)) {
    let i = e;
    do {
      if (i && t === i)
        return true;
      i = i.parentNode || i.host;
    } while (i);
  }
  return false;
}
function Gt2(t, e) {
  const n = O2(t, false, e === "fixed"), i = n.top + t.clientTop, o = n.left + t.clientLeft;
  return {
    top: i,
    left: o,
    x: o,
    y: i,
    right: o + t.clientWidth,
    bottom: i + t.clientHeight,
    width: t.clientWidth,
    height: t.clientHeight
  };
}
function ct2(t, e, n) {
  return e === "viewport" ? I2(Kt2(t, n)) : k2(e) ? Gt2(e, n) : I2(Ut2(T2(t)));
}
function Jt2(t) {
  const e = Y2(t), i = ["absolute", "fixed"].includes(C2(t).position) && P2(t) ? J2(t) : t;
  return k2(i) ? e.filter((o) => k2(o) && qt2(o, i) && L2(o) !== "body") : [];
}
function Qt2(t) {
  let {
    element: e,
    boundary: n,
    rootBoundary: i,
    strategy: o
  } = t;
  const r = [...n === "clippingAncestors" ? Jt2(e) : [].concat(n), i], s = r[0], l = r.reduce((a, d) => {
    const f2 = ct2(e, d, o);
    return a.top = W2(f2.top, a.top), a.right = it2(f2.right, a.right), a.bottom = it2(f2.bottom, a.bottom), a.left = W2(f2.left, a.left), a;
  }, ct2(e, s, o));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
var Zt2 = {
  getClippingRect: Qt2,
  convertOffsetParentRelativeRectToViewportRelativeRect: Yt2,
  isElement: k2,
  getDimensions: rt2,
  getOffsetParent: J2,
  getDocumentElement: T2,
  getElementRects: (t) => {
    let {
      reference: e,
      floating: n,
      strategy: i
    } = t;
    return {
      reference: It2(e, J2(n), i),
      floating: {
        ...rt2(n),
        x: 0,
        y: 0
      }
    };
  },
  getClientRects: (t) => Array.from(t.getClientRects()),
  isRTL: (t) => C2(t).direction === "rtl"
};
function te2(t, e, n, i) {
  i === void 0 && (i = {});
  const {
    ancestorScroll: o = true,
    ancestorResize: c2 = true,
    elementResize: r = true,
    animationFrame: s = false
  } = i, l = o && !s, a = c2 && !s, d = l || a ? [...k2(t) ? Y2(t) : [], ...Y2(e)] : [];
  d.forEach((p2) => {
    l && p2.addEventListener("scroll", n, {
      passive: true
    }), a && p2.addEventListener("resize", n);
  });
  let f2 = null;
  if (r) {
    let p2 = true;
    f2 = new ResizeObserver(() => {
      p2 || n(), p2 = false;
    }), k2(t) && !s && f2.observe(t), f2.observe(e);
  }
  let u2, h = s ? O2(t) : null;
  s && m();
  function m() {
    const p2 = O2(t);
    h && (p2.x !== h.x || p2.y !== h.y || p2.width !== h.width || p2.height !== h.height) && n(), h = p2, u2 = requestAnimationFrame(m);
  }
  return n(), () => {
    var p2;
    d.forEach((w2) => {
      l && w2.removeEventListener("scroll", n), a && w2.removeEventListener("resize", n);
    }), (p2 = f2) == null || p2.disconnect(), f2 = null, s && cancelAnimationFrame(u2);
  };
}
var ee2 = (t, e, n) => At2(t, e, {
  platform: Zt2,
  ...n
});
async function ne2(t, e, n, i) {
  if (!i)
    throw new Error("Must provide a positioning option");
  return await (typeof i == "string" ? oe2(t, e, n, i) : ie2(e, i));
}
async function oe2(t, e, n, i) {
  if (!n)
    throw new Error("Reference element is required for relative positioning");
  let o;
  return i === "auto" ? o = {
    middleware: [
      Vt2(),
      ot2(),
      nt2({ mainAxis: 5, crossAxis: 12 })
    ]
  } : o = {
    placement: i,
    middleware: [
      Ft2(),
      ot2(),
      nt2(5)
    ]
  }, te2(n, e, async () => {
    if ((!n.isConnected || !n.offsetParent) && se2(t))
      return;
    const { x: c2, y: r } = await ee2(n, e, o);
    Object.assign(e.style, {
      position: "absolute",
      left: `${c2}px`,
      top: `${r}px`
    });
  });
}
function ie2(t, e) {
  return t.style.position = "fixed", Object.entries(e).forEach(([n, i]) => {
    t.style[n] = i;
  }), () => {
  };
}
function se2(t) {
  switch (t.options.onPositionLost) {
    case "close":
      return t.close(), true;
    case "destroy":
      return t.destroy(), true;
    case "hold":
      return true;
  }
}
var re2 = {
  hideOnClickOutside: true,
  hideOnEmojiSelect: true,
  hideOnEscape: true,
  position: "auto",
  showCloseButton: true,
  onPositionLost: "none"
};
function ce2(t = {}) {
  return {
    ...re2,
    rootElement: document.body,
    ...t
  };
}
var le2 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>';
var lt2 = p(
  "popupContainer",
  "closeButton"
);
var ae2 = class {
  constructor(e, n) {
    this.isOpen = false, this.externalEvents = new le(), this.options = { ...ce2(n), ...$t(e) }, this.popupEl = document.createElement("div"), this.popupEl.classList.add(lt2.popupContainer), this.popupEl.classList.add(this.options.theme), n.className && this.popupEl.classList.add(n.className), this.options.showCloseButton && (this.closeButton = document.createElement("button"), this.closeButton.type = "button", this.closeButton.classList.add(lt2.closeButton), this.closeButton.innerHTML = le2, this.closeButton.addEventListener("click", () => {
      this.close();
    }), this.popupEl.appendChild(this.closeButton));
    const i = document.createElement("div");
    this.popupEl.appendChild(i), this.picker = Hs({ ...this.options, rootElement: i }), this.focusTrap = new st(), this.picker.addEventListener("data:ready", () => {
      this.focusTrap.activate(this.picker.el), this.picker.setInitialFocus();
    }), this.options.hideOnEmojiSelect && this.picker.addEventListener("emoji:select", () => {
      var o;
      this.close(), (o = this.triggerElement) == null || o.focus();
    }), this.options.hideOnClickOutside && (this.onDocumentClick = this.onDocumentClick.bind(this), document.addEventListener("click", this.onDocumentClick)), this.options.hideOnEscape && (this.handleKeydown = this.handleKeydown.bind(this), this.popupEl.addEventListener("keydown", this.handleKeydown)), this.referenceElement = this.options.referenceElement, this.triggerElement = this.options.triggerElement;
  }
  addEventListener(e, n) {
    this.externalEvents.on(e, n), this.picker.addEventListener(e, n);
  }
  removeEventListener(e, n) {
    this.externalEvents.off(e, n), this.picker.removeEventListener(e, n);
  }
  handleKeydown(e) {
    var n;
    e.key === "Escape" && (this.close(), (n = this.triggerElement) == null || n.focus());
  }
  async destroy() {
    this.isOpen && await this.close(), document.removeEventListener("click", this.onDocumentClick), this.picker.destroy(), this.externalEvents.removeAll();
  }
  toggle(e) {
    return this.isOpen ? this.close() : this.open(e);
  }
  async open({ triggerElement: e, referenceElement: n } = {}) {
    this.isOpen || (e && (this.triggerElement = e), n && (this.referenceElement = n), await this.initiateOpenStateChange(true), this.popupEl.style.opacity = "0", this.options.rootElement.appendChild(this.popupEl), await this.setPosition(), this.picker.reset(false), await this.animatePopup(true), await this.animateCloseButton(true), this.picker.setInitialFocus(), this.externalEvents.emit("picker:open"));
  }
  async close() {
    var e;
    !this.isOpen || (await this.initiateOpenStateChange(false), await this.animateCloseButton(false), await this.animatePopup(false), this.popupEl.remove(), this.picker.reset(), (e = this.positionCleanup) == null || e.call(this), this.focusTrap.deactivate(), this.externalEvents.emit("picker:close"));
  }
  getRunningAnimations() {
    return this.picker.el.getAnimations().filter((e) => e.playState === "running");
  }
  async setPosition() {
    var e;
    (e = this.positionCleanup) == null || e.call(this), this.positionCleanup = await ne2(
      this,
      this.popupEl,
      this.referenceElement,
      this.options.position
    );
  }
  awaitPendingAnimations() {
    return Promise.all(this.getRunningAnimations().map((e) => e.finished));
  }
  onDocumentClick(e) {
    var o;
    const n = e.target, i = (o = this.triggerElement) == null ? void 0 : o.contains(n);
    this.isOpen && !this.picker.isPickerClick(e) && !i && this.close();
  }
  animatePopup(e) {
    return I(
      this.popupEl,
      {
        opacity: [0, 1],
        transform: ["scale(0.9)", "scale(1)"]
      },
      {
        duration: 150,
        id: e ? "show-picker" : "hide-picker",
        easing: "ease-in-out",
        direction: e ? "normal" : "reverse",
        fill: "both"
      },
      this.options
    );
  }
  animateCloseButton(e) {
    if (this.closeButton)
      return I(
        this.closeButton,
        {
          opacity: [0, 1]
        },
        {
          duration: 25,
          id: e ? "show-close" : "hide-close",
          easing: "ease-in-out",
          direction: e ? "normal" : "reverse",
          fill: "both"
        },
        this.options
      );
  }
  async initiateOpenStateChange(e) {
    this.isOpen = e, await this.awaitPendingAnimations();
  }
};
var fe2 = `.picmo__popupContainer{display:flex;flex-direction:column;position:absolute}.picmo__popupContainer .picmo__closeButton{position:absolute;opacity:0;background:transparent;border:none;z-index:1;right:0;top:0;cursor:pointer;padding:4px;align-self:flex-end;transform:translate(50%,-50%);background:#999999;width:1.5rem;height:1.5rem;display:flex;align-items:center;justify-content:center;border-radius:50%}.picmo__popupContainer .picmo__closeButton:hover{background:var(--accent-color)}.picmo__popupContainer .picmo__closeButton svg{fill:#fff;width:1.25rem;height:1.25rem}
`;
var ue2 = Ss();
function pe2(t, e) {
  return ue2(fe2), new ae2({
    autoFocus: "auto",
    ...t
  }, e);
}
export {
  ae2 as PopupPickerController,
  pe2 as createPopup
};
//# sourceMappingURL=@picmo_popup-picker.js.map
